<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计owllook网络小说推荐系统]]></title>
    <url>%2F2019%2F02%2F22%2Fowllook-recommender%2F</url>
    <content type="text"><![CDATA[本文记录了我对owllook.net这一网络小说搜索引擎的推荐系统的分析与设计过程。这个项目是开源项目，地址在owllook repo，目前已经积累了一定的数据量，需要一个靠谱的推荐系统。注意我用到的数据是内部数据，并没有开源。 本文使用推荐算法包括：基于用户的协同过滤（UserCF）、基于物品的协同过滤（ItemCF）、基于流行度的推荐、随机推荐、基于用户标签相似度的推荐等算法。通过对比发现基于用户标签相似度的推荐算法表现效果最佳，目前已经将该算法在线上使用。 数据本文的数据主要是用户收藏的小说、小说的类型两大类。其中用户收藏的小说这个数据比较有说服力，相对于搜索和点击记录，收藏数据更能显现出用户对这个小说的喜爱。 在我使用的这批数据中，共有用户2420个，共有书籍1596本，所有用户共收藏书籍4780本。为了验证推荐系统的有效性，我们使用每个用户的70%的数据当做训练集，把剩下的30%当做测试集。也就是说基本上每个用户都会在训练集和测试集同时出现，但是这个用户读过的书不会同时出现。我们的目的就是通过分析这个用户读过的书（训练集），去给这个用户推荐他可能感兴趣的书籍。如果我们推荐的书籍中包括了用户测试集的书，说明我们这个推荐命中了。这里的推荐没有考虑时间因素。 每本书都会有至少一个标签，比如《文化入侵异世界》这本书的标签是“科幻、时空穿梭、二次元”，这个标签是起点中文网给打的，可以认为比较准确。 下面是对用户收藏的书籍的个数统计，横坐标代表收藏个数，纵坐标代表该收藏个数有多少人。可以看出大部分人都只收藏了很少的书籍，符合长尾效应。 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts6800')); // 指定图表的配置项和数据 var option = {"title":[{"left":"auto","top":"auto","textStyle":{"fontSize":18},"subtextStyle":{"fontSize":12}}],"toolbox":{"show":true,"orient":"vertical","left":"95%","top":"center","feature":{"saveAsImage":{"show":true,"title":"saveasimage"},"restore":{"show":true,"title":"restore"},"dataView":{"show":true,"title":"dataview"}}},"series_id":5375887,"tooltip":{"trigger":"item","triggerOn":"mousemove|click","axisPointer":{"type":"line"},"textStyle":{"fontSize":14},"backgroundColor":"rgba(50,50,50,0.7)","borderColor":"#333","borderWidth":0},"series":[{"type":"line","name":"用户统计","symbol":"emptyCircle","symbolSize":4,"smooth":false,"step":false,"showSymbol":true,"data":[[1,758.0],[2,228.0],[3,96.0],[4,60.0],[5,49.0],[6,32.0],[7,26.0],[8,12.0],[9,12.0],[10,15.0],[11,8.0],[12,8.0],[13,9.0],[14,5.0],[15,3.0],[16,8.0],[17,7.0],[18,3.0],[19,1.0],[20,4.0],[21,6.0],[22,1.0],[23,1.0],[24,1.0],[25,4.0],[26,1.0],[27,2.0],[28,1.0],[29,1.0],[33,2.0],[34,1.0],[35,1.0],[36,3.0],[38,1.0],[43,1.0],[57,1.0],[63,1.0],[373,1.0]],"label":{"normal":{"show":false,"position":"top","textStyle":{"fontSize":12}},"emphasis":{"show":true,"textStyle":{"fontSize":12}}},"lineStyle":{"normal":{"width":1,"opacity":1,"curveness":0,"type":"solid"}},"areaStyle":{"opacity":0},"markPoint":{"data":[]},"markLine":{"data":[]},"seriesId":5375887}],"legend":[{"data":["用户统计"],"selectedMode":"multiple","show":true,"left":"center","top":"top","orient":"horizontal","textStyle":{"fontSize":12}}],"animation":true,"xAxis":[{"show":true,"nameLocation":"middle","nameGap":25,"nameTextStyle":{"fontSize":14},"axisTick":{"alignWithLabel":false},"inverse":false,"boundaryGap":true,"type":"category","splitLine":{"show":false},"axisLine":{"lineStyle":{"width":1}},"axisLabel":{"interval":"auto","rotate":0,"margin":8,"textStyle":{"fontSize":12}},"data":[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,33.0,34.0,35.0,36.0,38.0,43.0,57.0,63.0,373.0]}],"yAxis":[{"show":true,"nameLocation":"middle","nameGap":25,"nameTextStyle":{"fontSize":14},"axisTick":{"alignWithLabel":false},"inverse":false,"boundaryGap":true,"type":"value","splitLine":{"show":true},"axisLine":{"lineStyle":{"width":1}},"axisLabel":{"interval":"auto","formatter":"{value}","rotate":0,"margin":8,"textStyle":{"fontSize":12}}}],"color":["#c23531","#2f4554","#61a0a8","#d48265","#749f83","#ca8622","#bda29a","#6e7074","#546570","#c4ccd3","#f05b72","#ef5b9c","#f47920","#905a3d","#fab27b","#2a5caa","#444693","#726930","#b2d235","#6d8346","#ac6767","#1d953f","#6950a1","#918597","#f6f5ec"]} // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 下面是对每本书被收藏次数统计，横坐标代表被收藏次数，纵坐标代表该被收藏次数有多少本。可以看出大部分书都只被收藏了很少次，只有少部分书被大量收藏，符合长尾效应。 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts2640')); // 指定图表的配置项和数据 var option = {"title":[{"left":"auto","top":"auto","textStyle":{"fontSize":18},"subtextStyle":{"fontSize":12}}],"toolbox":{"show":true,"orient":"vertical","left":"95%","top":"center","feature":{"saveAsImage":{"show":true,"title":"saveasimage"},"restore":{"show":true,"title":"restore"},"dataView":{"show":true,"title":"dataview"}}},"series_id":7652770,"tooltip":{"trigger":"item","triggerOn":"mousemove|click","axisPointer":{"type":"line"},"textStyle":{"fontSize":14},"backgroundColor":"rgba(50,50,50,0.7)","borderColor":"#333","borderWidth":0},"series":[{"type":"line","name":"书籍统计","symbol":"emptyCircle","symbolSize":4,"smooth":false,"step":false,"showSymbol":true,"data":[[1,1662.0],[2,294.0],[3,137.0],[4,65.0],[5,41.0],[6,19.0],[7,19.0],[8,11.0],[9,7.0],[10,4.0],[11,4.0],[12,6.0],[13,4.0],[15,5.0],[17,2.0],[18,2.0],[19,3.0],[20,1.0],[22,4.0],[23,1.0],[25,1.0],[26,2.0],[29,2.0],[30,1.0],[31,2.0],[32,1.0],[33,1.0],[36,1.0],[39,1.0],[42,1.0],[51,1.0],[52,1.0],[53,1.0],[54,1.0],[96,1.0]],"label":{"normal":{"show":false,"position":"top","textStyle":{"fontSize":12}},"emphasis":{"show":true,"textStyle":{"fontSize":12}}},"lineStyle":{"normal":{"width":1,"opacity":1,"curveness":0,"type":"solid"}},"areaStyle":{"opacity":0},"markPoint":{"data":[]},"markLine":{"data":[]},"seriesId":7652770}],"legend":[{"data":["书籍统计"],"selectedMode":"multiple","show":true,"left":"center","top":"top","orient":"horizontal","textStyle":{"fontSize":12}}],"animation":true,"xAxis":[{"show":true,"nameLocation":"middle","nameGap":25,"nameTextStyle":{"fontSize":14},"axisTick":{"alignWithLabel":false},"inverse":false,"boundaryGap":true,"type":"category","splitLine":{"show":false},"axisLine":{"lineStyle":{"width":1}},"axisLabel":{"interval":"auto","rotate":0,"margin":8,"textStyle":{"fontSize":12}},"data":[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,15.0,17.0,18.0,19.0,20.0,22.0,23.0,25.0,26.0,29.0,30.0,31.0,32.0,33.0,36.0,39.0,42.0,51.0,52.0,53.0,54.0,96.0]}],"yAxis":[{"show":true,"nameLocation":"middle","nameGap":25,"nameTextStyle":{"fontSize":14},"axisTick":{"alignWithLabel":false},"inverse":false,"boundaryGap":true,"type":"value","splitLine":{"show":true},"axisLine":{"lineStyle":{"width":1}},"axisLabel":{"interval":"auto","formatter":"{value}","rotate":0,"margin":8,"textStyle":{"fontSize":12}}}],"color":["#c23531","#2f4554","#61a0a8","#d48265","#749f83","#ca8622","#bda29a","#6e7074","#546570","#c4ccd3","#f05b72","#ef5b9c","#f47920","#905a3d","#fab27b","#2a5caa","#444693","#726930","#b2d235","#6d8346","#ac6767","#1d953f","#6950a1","#918597","#f6f5ec"]} // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 推荐算法下面开始分析推荐算法。 协同过滤一提到推荐算法，首先反应过来的就是协同过滤。协同过滤分为基于用户的协同过滤和基于物品的协同过滤。 基于用户的协同过滤算法（UserBasedCF） 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。 基于物品的协同过滤算法（ItemBasedCF） 这种算法给用户推荐和他之前喜欢的物品相似的物品。 这两种推荐算法只需要使用用户的历史收藏数据，所以算法比较简单，也有较好的可解释性。但是问题也很明显：如果用户的历史收藏数据太少，那么这两种算法就无效了。在我们的这个小说推荐系统中，数据只有几千条，并不算很多，不能保证协同过滤算法有太大的威力。 更多关于协同过滤的内容，可以看我这篇博客动手实现基于协同过滤的电影推荐系统。 基于流行度的推荐在用户收藏书籍个数统计和书籍被收藏个数统计的分析图中我们可以看到，事实上只有活跃的用户占少数、也只有少量的书籍比较热门。热门书籍大概可以从owllook.net这个搜索框下面的搜索排行中有所反映。 这个暗示着我们，或许可以使用基于流行度的推荐算法。即给用户直接推荐比较流行的书籍即可，很可能这个用户就喜欢。虽然这个方法很粗暴，但是对于整体效果来说，未必就差。 基于用户标签相似度的推荐这个想法来自基于用户的协同过滤算法，本质上是个基于内容的推荐算法。所谓基于内容的推荐算法，就是把物品做映射，使用更低维的数据表示该物品，在本项目中就是用户标签。在UserCF中，我们使用两个用户的收藏历史来做相似性分析，但是对于owllook来说，收藏历史不算多，那么就会造成两个用户的共同的收藏书籍很少，那么就无法有效地求用户余弦相似度。所以，这就引导了我们做一个书籍到标签的映射，计算两个用户的相似度不是使用两个用户的共同书籍，而是使用两个用户的共同标签。标签的个数肯定是很少的，所以就解决了无法求两个用户相似度的问题。 其实仔细想想还是很有道理的：只有看的书一样的两个用户才比较相似吗？其实并不是。直观上，对于小说来说，如果两个用户的口味比较一致就行。比如两个人都喜欢科幻，那么这两个人就比较相似。所以可以把其中一个人喜欢的，另一个人没看过的《三体》推荐过去。 总之，我们可以把每个用户收藏的书转化成标签之后，然后利用每个人的标签，求相似用户，然后根据相似用户做书籍推荐。 具体做法是： 求出每个用户的所有书籍累积的标签计数，比如用户A : {&quot;科幻&quot;:3, &quot;时空穿梭&quot;:2, &quot;二次元&quot;:4}； 求该用户和其他用户的余弦相似度，比如用户A : {&quot;用户B&quot; : 0.97, &quot;用户C&quot; : 0.86, &quot;用户D&quot; : 0.72}; 遍历每个相似用户的书籍，累加用户相似度得到书籍平分，比如用户B看过《三体》、《球形闪电》，用户C看过《球形闪电》，用户D看过《流浪地球》，那么给用户A推荐的书籍的打分为：用户A : {&quot;《三体》&quot; : 0.97,&quot;《球形闪电》&quot; : 1.83,&quot;《流浪地球》&quot; : 0.72。 对推荐的书籍按照打分排序，并把得分最高的TopK推荐给用户A. 评价指标本文采用的评价指标和《推荐系统实践》一致，分为精确率，召回率，覆盖率和新颖度。 精确率描述最终的推荐列表中有多少比例是发生过的用户—物品评分记录； 召回率描述有多少比例的用户—物品评分记录包含在最终的推荐列表中； 覆盖率反映了推荐算法发掘长尾的能力，覆盖率越高，说明推荐算法越能够将长尾中的物品推荐给用户； 流行度反映了推荐列表中物品的平均流行度。如果推荐出的物品都很热门，说明推荐的流行度很高，否则说明推荐结果比较新颖。 算法对比在上面的几节内容中，我们已经分析了本文的主要几个算法的工作原理，推荐系统的评价指标。真正地推荐过程分为4步： 构造训练集和预测集 训练推荐系统模型 给出推荐结果 评价推荐结果 所以我一共实现了5种推荐算法： UserCF，基于用户的协同过滤算法 ItemCF，基于物品的协同过滤算法 Random，随机推荐 Most Popular，推荐最流行物品 Tag Similar，根据用户标签相似度推荐 推荐10本书籍为了对比，我们一致使用推荐10本书籍，比如下面的含义就是用户h****的所有书籍标签、所有收藏的书籍、给他推荐的书籍： 12345User: h****User tags: &#123;&apos;上古先秦&apos;, &apos;东方玄幻&apos;, &apos;异术超能&apos;, &apos;都市&apos;, &apos;架空历史&apos;, &apos;玄幻&apos;, &apos;二次元&apos;, &apos;灵异&apos;, &apos;恐怖惊悚&apos;, &apos;幻想修仙&apos;, &apos;武侠仙侠&apos;, &apos;仙侠&apos;, &apos;历史&apos;&#125;User books: [&apos;剑来&apos;, &apos;圣墟&apos;, &apos;修真聊天群&apos;, &apos;牧神记&apos;, &apos;汉乡&apos;, &apos;逍遥游&apos;, &apos;深夜书屋&apos;, &apos;秦吏&apos;, &apos;三寸人间&apos;]recommend for userid = h****:[&apos;大王饶命&apos;, &apos;飞剑问道&apos;, &apos;修真聊天群&apos;, &apos;赘婿&apos;, &apos;太初&apos;, &apos;帝霸&apos;, &apos;一念永恒&apos;, &apos;诡秘之主&apos;, &apos;天道图书馆&apos;, &apos;永夜君王&apos;] 下面是当给每个用户推荐10本书的时候，各个推荐算法的结果对比： 推荐算法\评测指标 Precision Recall Coverage Popularity UserCF 0.49% 4.93% 45.69% 1.1230 ItemCF 0.08% 0.08% 52.77% 0.6141 Random 0.04% 0.34% 99.83% 0.8827 Most Popular 0.74% 7.45% 0.90% 3.5024 Tag Similar 1.43% 14.08% 7.96% 2.2894 在上面的结果中，我们可以看到，对于协同过滤来说，UserCF比ItemCF的准确和召回率多高出了不少，说明在我们的实验中，求相似用户然后做推荐的方式是有效果的。ItemCF表现差是因为书籍很多、被收藏的书主要是同样的那几个，导致我们不能很好的求不同书籍的相似情况。另外，我们看到ItemCF比UserCF的覆盖率更广、流行度更低，这说明ItemCF能更好的挖掘出书籍的长尾效应，能够把更冷门的书籍推荐出来。 随机推荐推荐准确率和召回率都比较低，说明随机猜的推荐效果很差。其覆盖率极高，流行度很低，这说明随机猜地推荐算法最能把所有的书籍都推荐出去了，但是我们都知道这种推荐做法不可取。 基于流行度的推荐算法，准确率和召回率比UserCF还要高。这说明我们在上面的分析是对的！由于owllook首页给出了排行榜，另外也可能由于比较火的书确实有很多人喜欢看，所以我们只要把最火的10本书无脑推荐给所有人都能得到很高的准确和召回。其实这引发了我们思考：推荐算法越复杂越好吗？未必见得。基于流行度的推荐的覆盖率很低，这是显然地，毕竟只推荐了最火的10本。流行度是所有推荐算法中最高的，这个指标说明了我们推荐的确实都是最流行的书，并没有很好地把所有书籍都推荐出去的能力。 最后，我们设计的基于用户标签相似度的算法表现最好，准确率和召回率都是最高的，而且领先了一大截。这说明用户对于小说的追求确实是和小说的类型有关，给用户推荐口味相投的用户收藏的书籍确实是是个明智之举。值得注意的是这个算法的召回率，因为召回率反映了推荐算法能不能把用户想要的东西都推荐给他，14%的召回非常高了。这个算法的覆盖率8%左右，相对于协同过滤和随机猜测都很小，说明这个算法并不能太好的挖掘书籍的长尾效应；但是这个覆盖率也远高于基于流行度的推荐，说明这个算法还是推荐了不少的新鲜书籍给用户。最后，这个算法的流行度小于基于流行度的推荐算法，大于UserCF，这个说明了该算法也推荐了不少流行书籍。但上文已经解释过了，推荐流行书籍并不代表是错的，因为流行书籍确实受欢迎。 上面是推荐10本书的情况下，不同推荐算法的对比，我们可以得出结论：本文设计的基于用户标签相似度的推荐算法表现非常好，给用户推荐的书籍受到了用户喜爱，同时也有一定地挖掘长尾效应的能力。 推荐20本书籍为了做进一步地对比，我将推荐书籍的个数扩大到20本，比如下面的含义就是用户y***的所有书籍标签、所有收藏的书籍、给他推荐的书籍： 12345User: y***User tags: &#123;&apos;武侠仙侠&apos;, &apos;玄幻&apos;, &apos;都市&apos;, &apos;武侠幻想&apos;, &apos;架空历史&apos;, &apos;都市生活&apos;, &apos;两晋隋唐&apos;, &apos;虚拟网游&apos;, &apos;未来世界&apos;, &apos;东方玄幻&apos;, &apos;武侠&apos;, &apos;科幻&apos;, &apos;二次元&apos;, &apos;游戏&apos;, &apos;历史&apos;&#125;User books: [&apos;尘劫录&apos;, &apos;大王饶命&apos;, &apos;凡人修仙传仙界篇&apos;, &apos;天骄战纪&apos;, &apos;霸汉&apos;, &apos;修炼狂潮&apos;, &apos;惊悚乐园&apos;, &apos;江山美色&apos;, &apos;死人经&apos;, &apos;孺子帝&apos;, &apos;多宝浮屠&apos;, &apos;赘婿&apos;, &apos;枭臣&apos;, &apos;长宁帝军&apos;, &apos;天下第九&apos;, &apos;三寸人间&apos;, &apos;牧神记&apos;, &apos;剑来&apos;, &apos;行镖&apos;, &apos;最强反派系统&apos;, &apos;星际游轮&apos;]recommend for userid = y***:[&apos;圣墟&apos;, &apos;太初&apos;, &apos;剑来&apos;, &apos;赘婿&apos;, &apos;帝霸&apos;, &apos;飞剑问道&apos;, &apos;修真聊天群&apos;, &apos;诡秘之主&apos;, &apos;天道图书馆&apos;, &apos;汉乡&apos;, &apos;永夜君王&apos;, &apos;大道朝天&apos;, &apos;三寸人间&apos;, &apos;武炼巅峰&apos;, &apos;元尊&apos;, &apos;一念永恒&apos;, &apos;明朝败家子&apos;, &apos;斗战狂潮&apos;, &apos;斗破苍穹&apos;, &apos;将夜&apos;] 下面是当给每个用户推荐20本书的时候，各个推荐算法的结果对比： 推荐算法\评测指标 Precision Recall Coverage Popularity UserCF 0.28% 5.50% 59.08% 0.8878 ItemCF 0.08% 1.48% 62.53% 0.5854 Random 0.02% 0.36% 100.00% 0.8739 Most Popular 0.65% 12.65% 1.57% 3.2299 Tag Similar 0.87% 17.52% 15.33% 2.1372 从上面的结果中，我们可以看出，我们设计的基于用户标签相似度的推荐算法准确率、召回率依然最高，覆盖率和流行率处于中等水平，仍然是效果最好的算法。总体来看，当推荐书的个数变多时，所有的算法准确率降低了、召回率提高了。很显然，当推荐数目变多时，推荐的书籍就更不准了，但推荐的书籍就更全了。这告诉我们应该根据项目需求，合理选择推荐系统的优化目标。另外，我们注意到Most Similar算法与Most Similar算法的准确率和召回率更加接近了，这是否说明Most Similar已经退化成Most Popular了呢？这么说有一定道理，但并不完全是。有道理是因为比较流行的书籍本来就受欢迎，Most Similar也做推荐是理所当然的；不完全对的地方在于Most Similar的覆盖率还是非常大的，说明对长尾的书籍也做了推荐；流行度指标较低，说明推荐了一些冷门的书籍。 推荐解释这里说的推荐解释，是给我们一个直观上的感受：我们的推荐结果是有说服力的。对于我们的基于用户标签相似度的推荐算法，可解释性非常强，因为我们只要证明推荐的结果书籍的标签是用户喜欢的标签即可。我们把推荐书籍的个数设为10，推荐书籍的同时打印出这个书籍的标签。 对于用户s********，他喜欢的标签是幻想修仙和仙侠，推荐的这10本书基本比较符合，同时也推荐了两本玄幻的书籍，相当于去探索用户的其他兴趣。 123456789101112131415User: s********User tags: &#123;&apos;幻想修仙&apos;, &apos;仙侠&apos;&#125;User books: [&apos;系统的超级宗门&apos;, &apos;明朝败家子&apos;, &apos;兔子必须死&apos;, &apos;我真是医二代&apos;, &apos;万界之最强大&apos;, &apos;听说我死后超凶&apos;, &apos;神豪的悠闲人生&apos;, &apos;创业吧学霸大人&apos;, &apos;这个末世有点槽&apos;, &apos;逆天邪神&apos;]recommend for userid = s********:一念永恒 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]飞剑问道 [&apos;仙侠&apos;, &apos;古典仙侠&apos;]圣墟 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]牧神记 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]道君 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]凡人修仙传 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]剑来 [&apos;武侠仙侠&apos;]斗战狂潮 [&apos;仙侠&apos;, &apos;修真文明&apos;]蛊真人 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]大王饶命 [&apos;都市&apos;, &apos;都市生活&apos;, &apos;二次元&apos;][&apos;一念永恒&apos;, &apos;飞剑问道&apos;, &apos;圣墟&apos;, &apos;牧神记&apos;, &apos;道君&apos;, &apos;凡人修仙传&apos;, &apos;剑来&apos;, &apos;斗战狂潮&apos;, &apos;蛊真人&apos;, &apos;大王饶命&apos;] 对于用户陈**，他喜欢的书籍标签是科幻和二次元，看出推荐的书籍都是比较接近他的口味的。 1234567891011121314User: 陈**User tags: &#123;&apos;未来世界&apos;, &apos;史诗奇幻&apos;, &apos;奇幻&apos;, &apos;科幻&apos;, &apos;时空穿梭&apos;, &apos;二次元&apos;&#125;User books: [&apos;放开那个女巫&apos;, &apos;两界搬运工&apos;, &apos;修真四万年&apos;]recommend for userid = 陈**:大王饶命 [&apos;都市&apos;, &apos;都市生活&apos;, &apos;二次元&apos;]诡秘之主 [&apos;玄幻&apos;, &apos;异世大陆&apos;, &apos;二次元&apos;]修真聊天群 [&apos;都市&apos;, &apos;异术超能&apos;, &apos;二次元&apos;]修真四万年 [&apos;科幻&apos;, &apos;未来世界&apos;]赘婿 [&apos;历史&apos;, &apos;架空历史&apos;]学霸的黑科技系统 [&apos;科幻&apos;, &apos;超级科技&apos;]牧神记 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]异常生物见闻录 [&apos;科幻&apos;, &apos;时空穿梭&apos;, &apos;二次元&apos;]天道图书馆 [&apos;玄幻&apos;, &apos;异世大陆&apos;][&apos;大王饶命&apos;, &apos;诡秘之主&apos;, &apos;修真聊天群&apos;, &apos;修真四万年&apos;, &apos;赘婿&apos;, &apos;学霸的黑科技系统&apos;, &apos;牧神记&apos;, &apos;异常生物见闻录&apos;, &apos;大医凌然&apos;, &apos;天道图书馆&apos;] 对于用户风**，他喜欢的标签是历史和武侠，这个推荐的书籍非常符合他的口味。 1234567891011121314User: 风**User tags: &#123;&apos;清史民国&apos;, &apos;传统武侠&apos;, &apos;两宋元明&apos;, &apos;历史&apos;, &apos;历史军事&apos;, &apos;架空历史&apos;, &apos;武侠&apos;&#125;User books: [&apos;刺明&apos;, &apos;明扬天下&apos;, &apos;草清&apos;, &apos;三国之兵临天下&apos;, &apos;顺明&apos;, &apos;指南录&apos;, &apos;纸花船&apos;, &apos;明贼&apos;, &apos;乱世扬明&apos;, &apos;明末传奇&apos;, &apos;大明1617&apos;, &apos;大明最后一个太子&apos;, &apos;汉儿不为奴&apos;]recommend for userid = 风**:赘婿 [&apos;历史&apos;, &apos;架空历史&apos;]汉乡 [&apos;历史&apos;, &apos;架空历史&apos;]唐砖 [&apos;历史&apos;, &apos;两晋隋唐&apos;]带着仓库到大明 [&apos;历史&apos;, &apos;两宋元明&apos;]剑来 [&apos;武侠仙侠&apos;]秦吏 [&apos;历史&apos;, &apos;上古先秦&apos;]锦衣夜行 [&apos;历史&apos;, &apos;两宋元明&apos;]圣墟 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]晚明 [&apos;历史&apos;, &apos;两宋元明&apos;][&apos;赘婿&apos;, &apos;汉乡&apos;, &apos;唐砖&apos;, &apos;带着仓库到大明&apos;, &apos;剑来&apos;, &apos;秦吏&apos;, &apos;锦衣夜行&apos;, &apos;明朝败家子&apos;, &apos;圣墟&apos;, &apos;晚明&apos;] 当然，也存在一些口味比较复杂的用户，收藏了很多种类的书籍，推荐的结果也应该包括了对应的种类。比如对于用户青**，推荐的结果留给读者自行判断吧。 123456789101112131415User: 青**User tags: &#123;&apos;游戏异界&apos;, &apos;二次元&apos;, &apos;恐怖惊悚&apos;, &apos;史诗奇幻&apos;, &apos;灵异&apos;, &apos;都市&apos;, &apos;古典仙侠&apos;, &apos;东方玄幻&apos;, &apos;进化变异&apos;, &apos;修真文明&apos;, &apos;异世大陆&apos;, &apos;都市生活&apos;, &apos;灵异鬼怪&apos;, &apos;幻想修仙&apos;, &apos;黑暗幻想&apos;, &apos;奇幻&apos;, &apos;科幻&apos;, &apos;游戏&apos;, &apos;玄幻&apos;, &apos;仙侠&apos;&#125;User books: [&apos;怪谈研究会&apos;, &apos;就是个道士&apos;, &apos;最初的寻道者&apos;, &apos;恶神当道&apos;, &apos;我是仙凡&apos;, &apos;道辟九霄&apos;, &apos;当个法师闹革命&apos;, &apos;炼道长生&apos;, &apos;一世之尊&apos;, &apos;问镜&apos;, &apos;原始战记&apos;, &apos;极度尸寒&apos;, &apos;恐怖邮差&apos;, &apos;玄门封神&apos;, &apos;封仙&apos;, &apos;蛊真人&apos;, &apos;这世界的土著好凶猛&apos;, &apos;诸天纪&apos;, &apos;仙路云霄&apos;, &apos;旧日篇章&apos;, &apos;深夜书屋&apos;, &apos;修真新时代&apos;, &apos;白中仙的修道生涯&apos;, &apos;侠道行&apos;, &apos;道门振兴系统&apos;, &apos;难道我是神&apos;, &apos;我假装会异能&apos;, &apos;我当道士那些年&apos;, &apos;绿洲中的领主&apos;, &apos;与妖怪的二三事&apos;, &apos;道吟&apos;, &apos;氪金魔主&apos;, &apos;一品修仙&apos;, &apos;全球高武&apos;, &apos;黑夜玩家&apos;, &apos;民国谍影&apos;]recommend for userid = 青**:圣墟 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]飞剑问道 [&apos;仙侠&apos;, &apos;古典仙侠&apos;]牧神记 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]一念永恒 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]大王饶命 [&apos;都市&apos;, &apos;都市生活&apos;, &apos;二次元&apos;]剑来 [&apos;武侠仙侠&apos;]斗战狂潮 [&apos;仙侠&apos;, &apos;修真文明&apos;]太初 [&apos;玄幻&apos;, &apos;东方玄幻&apos;]逆天邪神 [&apos;仙侠&apos;, &apos;幻想修仙&apos;]道君 [&apos;仙侠&apos;, &apos;幻想修仙&apos;][&apos;圣墟&apos;, &apos;飞剑问道&apos;, &apos;牧神记&apos;, &apos;一念永恒&apos;, &apos;大王饶命&apos;, &apos;剑来&apos;, &apos;斗战狂潮&apos;, &apos;太初&apos;, &apos;逆天邪神&apos;, &apos;道君&apos;] 探讨本文设计的基于用户标签相似度的推荐算法有没有什么缺点呢？我认为也是有的。 首先，这个算法仍然是基于相似度的算法，那么就不可避免地涉及到推荐系统冷启动问题。当一个新用户加入的时候，他的喜好是未知的，那么该算法也就失效了。 其次，在实验过程中发现，并不是每一本书都会有对应的标签，那么用户如果看了几本没有标签的书，那么就没法给他做推荐了。另外，如果我们的推荐算法有效的前提是书籍的标签是准确的，这个并不是那么容易确定的。 再者，本文对每个要推荐的小说累加了用户的相似度，然后根据小说得分的TopK做的推荐。那么不同的相似度计算方式会影响推荐结果。这个需要在实验中去验证选择。 对于前两个问题，可以考虑使用基于流行度的推荐算法作为补充。即，我们遇到无法推荐的情况时，直接把流行的书籍推荐给他。上文的推荐算法对比已经说明了，流行书籍推荐是有效的。 结论本文设计的基于用户标签相似度的网络小说推荐系统，在推荐系统的各个评测指标上，表现都很出色。目前已经投入线上使用当中。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现基于协同过滤的电影推荐系统]]></title>
    <url>%2F2018%2F06%2F12%2FMovieLens-Recommender%2F</url>
    <content type="text"><![CDATA[项亮的《推荐系统实践》是一本面向推荐系统初学者的好书。这本书中间花了不少的篇幅去介绍了推荐系统中很重要的一个算法：协同过滤。囿于书中的篇幅限制，作者只给出了核心部分的代码。基于此书内容，我动手实现了基于用户的协同过滤算法和基于物品的协同过滤算法，并在MovieLens数据集上做了测试，效果令人满意。现在总结一下自己对协同过滤系统的理解和动手实践过程的经验。 本电影推荐系统已开源在：https://github.com/fuxuemingzhu/MovieLens-Recommender 协同过滤理论协同过滤算法（Collaborative Filtering，CF）是只基于用户的历史行为对用户未来的购买习惯进行预测的一种算法。对于协同过滤的算法，最著名的、在业界得到最广泛应用的算法是基于邻域的方法，而基于邻域的方法主要包含下面两种算法。 基于用户的协同过滤算法（UserBasedCF） 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。 基于物品的协同过滤算法（ItemBasedCF） 这种算法给用户推荐和他之前喜欢的物品相似的物品。 （对于两种算法的基本概念我就不详细解读了，可以看《推荐系统实践》或者IBM的文章推荐引擎初探。） 因为这两种算法都是基于求邻域的，并且直观上UserBasedCF更容易理解，所以UserBasedCF比ItemBasedCF提出的更早一点。关于协同过滤理论，最值得一看的论文就是亚马逊发表的《Amazon.com Recommendations Item-to-Item Collaborative Filtering》。这篇论文是ItemBasedCF开山之作，很值得学习。 这篇论文的主要思想是： 在 User-based 方法中，随着用户数量的不断增多，在大数量级的用户范围内进行“最近邻搜索”会成为整个算法的瓶颈。Item-based 方法通过计算项之间的相似性来代替用户之间的相似性。对于项来讲，它们之间的相似性要稳定很多，因此可以离线完成工作量最大的相似性计算步骤，从而大大降低了在线计算量，提高推荐效率。 在 Item-based 方法中，要对 A 和 B 进行项相似性计算，通常分为两步：1）找出同时对 A 和 B 打过分的组合；2）对这些组合进行相似度计算，常用的算法包括：皮尔森相关系数、余弦相似性、调整余弦相似性和条件概率等。 这篇论文中也提出了可以只计算购买了这个物品的用户和其购买的其他物品的相似性来简化计算，项亮的书里也有用到，所以我实现的时候也采用了。 其实，很容易看出协同过滤算法的思想非常简单淳朴：用户之前的行为记录会反映出用户-用户的相关性（UserBasedCF）或者物品-物品的相关性（ItemBasedCF）。也就是UserBasedCF是基于用户的历史信息求用户的相关性，然后根据该用户的相似用户购买了的物品产生推荐信息；ItemBasedCF是基于用户的历史信息求物品的相关性，然后根据用户购买了的物品产生推荐信息。 评测指标本文采用的评测指标和《推荐系统实践》一致，分为精确率，召回率，覆盖率和新颖度。 精确率描述最终的推荐列表中有多少比例是发生过的用户—物品评分记录； 召回率描述有多少比例的用户—物品评分记录包含在最终的推荐列表中； 覆盖率反映了推荐算法发掘长尾的能力，覆盖率越高，说明推荐算法越能够将长尾中的物品推荐给用户； 流行度反映了推荐列表中物品的平均流行度。如果推荐出的物品都很热门，说明推荐结果偏向于流行物品，否则说明推荐结果比较新颖。 对用户u推荐N个物品（记为R(u)），令用户u在测试集上喜欢的物品集合为T(u)，那么各个评测指标的公式如下： 算法步骤基于用户的协同过滤算法 基于用户的协同过滤算法主要包括两个步骤。 (1) 找到和目标用户兴趣相似的用户集合。(2) 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。 求用户的相似性矩阵的时候，使用的余弦相似度。 由于两个用户之间可能根本没有购买过同样的物品，所以直接求用户两两之间的相似性矩阵浪费计算资源。所以使用物品—用户倒排表，这样可以很轻易地看出哪些用户购买了同样的商品，只要两个用户在同一个物品的用户表格里出现，就直接把他们两个用户的共现矩阵C[u][v]+1，最终就可以得到所有用户之间不为0的C[u][v]。 上面计算的是余弦相似度的分子，如果要求用户之间的相似性矩阵还要除以用户购买物品个数的乘积的算数平方根。 得到用户之间的兴趣相似度后， UserCF算法会计算与该用户兴趣最相似的K个用户的购买记录中的每个物品的兴趣程度。如下的公式度量了UserCF算法中用户u对物品i的感兴趣程度： 所以，只要找出和该用户最相似的K个用户的购买记录，对每个商品打分，得分最高的N个物品推荐给用户即可。 基于用户的协同过滤算法的改进上面的基于用户的协同过滤算法没有对流行的商品进行惩罚，更有根据的做法是惩罚用户u和用户v共同兴趣列表中热门物品对他们相似度的影响。该改进算法称为User-IIF算法。 基于物品的协同过滤算法 根据影响最广的，被引用的次数也最多的一篇推荐系统论文《Item-Based Collaborative Filtering Recommendation Algorithms》，Item-based算法分为两步： （1）相似度计算，得到各item之间的相似度 基于余弦（Cosine-based）的相似度计算 基于关联（Correlation-based）的相似度计算 调整的余弦（Adjusted Cosine）相似度计算 （2）预测值计算，对用户未打分的物品进行预测 加权求和。用户u已打分的物品的分数进行加权求和，权值为各个物品与物品i的相似度，然后对所有物品相似度的和求平均，计算得到用户u对物品i打分。 回归。如果两个用户都喜欢一样的物品，因为打分习惯不同，他们的欧式距离可能比较远，但他们应该有较高的相似度 。在通过用线性回归的方式重新估算一个新的R(u,N). 本文采用的是余弦相似度和加权求和的方式，主要的步骤和基于用户的协同过滤算法很接近，就不再赘述，可以看书、论文或者我的代码。 基于物品的协同过滤算法的改进考虑到可能有用户对物品产生了大量的行为，那么这个用户的购买记录将对众多的书产生了相似度影响。所以可以对用户活跃度进行惩罚，活跃用户对物品相似度的贡献应该小于不活跃的用户，即ItemCF-IUF算法： 电影推荐系统实现我在实现MovieLens-Recommender时，花了很多的时间做了很好的优化。把不同的推荐算法分成独立文件，每个文件的每个函数都有详细的注释，变量名等通俗易懂，很适合详细看看。 推荐过程分为4步： 构造训练集和预测集 训练推荐系统模型 给出推荐结果 评价推荐结果 为了对比协同过滤和其他推荐算法的区别，所以我一共实现了六种推荐算法： UserCF ItemCF UserCF-IIF ItemCF-IUF Random Most Popular 本项目使用的数据集是Movielens-1M和Movielens-100k，当然也可以很简单的换成其他数据集。运行的方式很简单，修改main.py里的参数为你想要的即可： dataset_name = &apos;ml-100k&apos; # dataset_name = &apos;ml-1m&apos; # model_type = &apos;UserCF&apos; # model_type = &apos;UserCF-IIF&apos; # model_type = &apos;ItemCF&apos; # model_type = &apos;Random&apos; # model_type = &apos;MostPopular&apos; model_type = &apos;ItemCF-IUF&apos; test_size = 0.1 另外，因为当test_size不变时，训练的模型也不会有变化，所以我在运行的时候会保存已有模型，再次运行相同参数的推荐时不用再重新训练模型，大大加快了推荐速度。在求相似性矩阵时，使用defaultdict可以大幅优化速度，这个也是我的一个经验。 运行时会打印进度，最后给出推荐结果，比如在ml-1m上训练的ItemCF的推荐结果如下： recommend for userid = 1: [&apos;1196&apos;, &apos;364&apos;, &apos;1265&apos;, &apos;318&apos;, &apos;2081&apos;, &apos;1282&apos;, &apos;1198&apos;, &apos;2716&apos;, &apos;1&apos;, &apos;2096&apos;] recommend for userid = 100: [&apos;2916&apos;, &apos;1580&apos;, &apos;457&apos;, &apos;1240&apos;, &apos;589&apos;, &apos;1291&apos;, &apos;780&apos;, &apos;1036&apos;, &apos;1610&apos;, &apos;1214&apos;] recommend for userid = 233: [&apos;1022&apos;, &apos;594&apos;, &apos;1282&apos;, &apos;2087&apos;, &apos;2078&apos;, &apos;1196&apos;, &apos;608&apos;, &apos;2081&apos;, &apos;593&apos;, &apos;1393&apos;] recommend for userid = 666: [&apos;296&apos;, &apos;1704&apos;, &apos;593&apos;, &apos;356&apos;, &apos;1196&apos;, &apos;589&apos;, &apos;1580&apos;, &apos;50&apos;, &apos;1393&apos;, &apos;1&apos;] recommend for userid = 888: [&apos;2916&apos;, &apos;457&apos;, &apos;480&apos;, &apos;2628&apos;, &apos;1265&apos;, &apos;1610&apos;, &apos;1198&apos;, &apos;1573&apos;, &apos;2762&apos;, &apos;1527&apos;] 打印完推荐结果之后，会评估模型。评估模型的方式是对每个用户进行推荐，最后使用评估指标进行评测，所以这个步骤可能相对较慢。比如某次的评估过程如下： Test recommendation system start... steps(0), 0.10 seconds have spent.. steps(1000), 291.42 seconds have spent.. steps(2000), 627.60 seconds have spent.. steps(3000), 898.21 seconds have spent.. steps(4000), 1219.94 seconds have spent.. steps(5000), 1523.29 seconds have spent.. steps(6000), 1817.46 seconds have spent.. Test recommendation system success. total step number is 6040 total 1829.26 seconds have spent precision=0.1900 recall=0.1147 coverage=0.1673 popularity=7.3911 推荐结果评价在测试集大小选为0.1的情况下，使用本项目对两个数据集进行了推荐并评估，得出以下的表格。基本和书中的结果一致。 Movielens 1M: Movielens 1M Precision Recall Coverage Popularity UserCF 19.84% 11.97% 28.16% 7.2023 ItemCF 19.00% 11.47% 16.73% 7.3911 UserCF-IIF 19.77% 11.93% 29.62% 7.1660 ItemCF-IUF 18.71% 11.29% 15.03% 7.4748 Random 0.54% 0.33% 100.00% 4.4075 Most Popular 10.59% 6.39% 2.76% 7.7462 Movielens 100k: Movielens 100k Precision Recall Coverage Popularity UserCF 19.69% 18.50% 22.20% 5.4928 ItemCF 17.89% 16.80% 13.23% 5.6202 UserCF-IIF 19.57% 18.38% 22.74% 5.4716 ItemCF-IUF 20.38% 12.30% 17.30% 7.3643 Random 0.82% 0.77% 99.64% 3.0332 Most Popular 10.54% 9.90% 4.07% 5.9578 总结本文用精简的篇幅概括了协同过滤的思想，并穿插了两篇最重要的协同过滤论文。算法实现本身并不难，可以把书中的代码作为参考，实现一个系统的难点应该在于构思框架、优化算法、如何评估。我觉得这个项目本身的可参考意义还是很大的，希望对大家有所帮助。 本电影推荐系统的所有代码都已经更新到仓库：https://github.com/fuxuemingzhu/MovieLens-Recommender，欢迎Fork和Star。 走心推广因为本博客部署在Digital Ocean 服务器上，每个月都要有5美元的成本，对于学生党来说也是不小开支。所以既然你能看到这篇博客的话，希望你能帮助我一下，鼓励我写出更好的文章。 Digital Ocean 服务器购买如果你也需要购买服务器，强烈推荐Digital Ocean，推荐原因如下： 基础套餐很便宜，每月最低5美元 服务器资源很给力，基础套餐配置是512MB内存，20GB的SSD硬盘，带宽不限制 可以搭建ShadowSocks，实现科学上网（特别实用！！） 支持ipv6，轻松解决校园网流量不够用的问题 我使用的是san francisco节点，搭建好ss之后，看油管1080p视频轻松无压力！！ 你如果使用我的这个网址注册Digital Ocean，你可以得到10美元的代金券，我也能赚到一点，就是这个链接：https://m.do.co/c/86d4e56f6c7a。 另外，如果你也是学生，有校园网邮箱，即可申请GitHub的Student Pack，免费送你50美刀的Digital Ocean代金券！地址是：https://education.github.com/pack/offers。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现北邮人BT模拟登录]]></title>
    <url>%2F2017%2F08%2F25%2Fbyrbt-login%2F</url>
    <content type="text"><![CDATA[如果问大家离开北邮最不舍的东西是什么？很多人肯定会脱口而出：北邮人BT！显然，北邮人BT已经融为每个BYR生活的一部分了。那么就从这个网站下手，练一练Python的爬虫吧。 很早之前写这篇文章时，对下载北邮人BT的资源的理解是先通过模拟北邮人BT登录，然后用代码下载资源。现在觉得这么做太复杂了，所以这篇文章就改成用python模拟登录北邮人BT的教程吧。 教程所需环境下面是本文核心的运行环境，没有在其他环境下运行和测试，推荐大家和我采用相同的环境。 Python 3.x 支持ipv6的服务器，本文使用Digital Ocean 大家可能和我一样在购买Digital Ocean之后想着如何让它发挥出更大的作用，我发现Digital Ocean支持ipv6，因此，我就想到能不能让它作为ipv4和ipv6的中转站，实现很多有意思的事情，于是就萌发了在校外下载北邮人BT资源的想法。 采用本教程的方法能够实现在校外的无ipv6的环境访问和下载北邮人BT资源到你的电脑，刷BT分享率，简直不要再赞。 更多关于选择Digital Ocean的理由可以见文末。 前期配置在购买DO服务器之后，会获得v4和v6两个地址，这两个地址都能访问DO。如果你没有ipv6的地址，但是你可以通过ipv4连接到DO服务器，然后让服务器通过ipv6访问和下载BT资源，资源先下载到服务器上，最后通过ipv4传到你的电脑上。这就是本文的思路。 在购买服务器完成之后，建议大家配置shadowsocks，这真是个好东西，不仅可以实现科学上网，还可以让你在v4的环境下访问v6的网页，效果可以看下图： 上图是在我把shadowsocks设置为全局模式时，能够使用浏览器访问北邮人BT，但系统没有ipv6地址，所以命令行可以连接到北邮人论坛却无法连接到北邮人BT。 这样做可以让你挑选北邮人BT的资源，但是因为没有ipv6的环境，所以不能方便地通过uTorrent等客户端下载资源。我们的做法是在自己电脑上使用shadowsocks代理访问北邮人BT挑选资源，得到想要下载的资源的id，然后在服务器上运行python脚本下载该id对应的资源，再通过ssh或者ftp传到本地电脑。 登录分析前文已经分析了，必须实现在DO服务器上能模拟登录北邮人BT，才能下载资源。故我们首先实现模拟登录BT。 网站模拟登录的分析过程可以参考之前的模拟登录北邮人论坛的文章，这里简单分析BT的模拟登录过程。 在浏览器上打开北邮人BT，退出登录，即在http://bt.byr.cn/login.php 界面，按F12打开开发者选项，选择Network选项卡，勾上Preserve log选项。 然后填写用户名密码、验证码，点击登录，如果填写的正确就能跳转到BT主界面。 从上面的截图能看出来，在登录BT的时候向http://bt.byr.cn/takelogin.php通过POST方式发送了4个参数，包括用户名，密码，验证码，还有验证码图片的hash。前面的三个参数都是自己填写的，但是验证码的hash从哪里找出来呢？难道自己计算吗？ 还好，通过在源代码中搜索imagehash，可以发现出现了两次，一次是图片的链接，一次是一个隐藏的输入框，输入框里包含着正确的iamgehash。如下图： 综上分析，我们已经可以把登录要提交的所有信息全部分析出来了，可以在源代码中使用正则表达式等工具提取出imagehash，但验证码要怎么处理呢？ 验证码处理前面虽然找出了验证码图片的hash，但是没法找出验证码图片对应的字符串（能找出的话验证码也没存在的意义了）。我们可以推测，当我们提交验证码字符串的时候，服务器会进行输入的验证码字符串和验证码图片hash的验证，如果匹配说明验证码正确。下面我们要解决验证码的问题。 处理验证码一般有几个思路： 手动填写 机器学习模型处理 第三方服务 这里为了方便，直接使用手动填写方式即可。思路是这样的，先用Python请求到登录页的网址，然后把验证码图片保存下来，再然后直接打开图片查看，把验证码填写即可。 如果你在自己电脑上模拟登录可以很简单的用图片查看器打开图片，但是如果在服务器上运行脚本的话该怎么办呢？我这里提供几个思路。 catimg在命令行中显示图片（不清晰） 把图片下载到本地查看（麻烦） 把图片转成字符画在命令行显示（代码量大） 我用的比较高逼格的第三种方式，效果如下： 能在终端中查看到验证码图片的话就能手动输入了~至此模拟登录要找到各个参数已经完全找到了。 保存cookies我们没有必要每次访问bt都去模拟登录，这样很麻烦。为了方便我们可以把cookies保存，以后使用cookies自动登录即可。 完整代码下面是完整的代码，将代码保存成.py文件再传到DO服务器，用Python命令运行。 运行之后，当前目录下会生成check_code.jpg,imgtochar.txt,cookies.txt等文件。请不要删除cookies.txt文件，这是以后登录使用的cookies。程序运行时会自动监测当前文件夹下是否存在cookies.txt，如果不存在会执行手动输入用户名密码验证码的登录操作，否则会直接使用cookies登录。 密码输入采用不显示的方式，不用担心密码没输上去。这是在服务器上运行程序的结果，注意，第一次需要输入用户名密码验证码，第二次登录直接使用cookies登录、不用再次输入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# coding=utf-8import osimport reimport pickleimport requestsimport requests.utilsfrom PIL import Imageimgpath = 'check_code.jpg'ascii_char = list(r"$@&amp;%B#... ")def select_ascii_char(r, g, b): gray = int((19595 * r + 38469 * g + 7472 * b) &gt;&gt; 16) # ‘RGB－灰度值’转换公式 unit = 256.0 / len(ascii_char) # ascii_char中的一个字符所能表示的灰度值区间 return ascii_char[int(gray / unit)]# 返回给定路径图片的字符表示，用户在此还可以指定输出字符画的宽度和高度def output(imgpath, width=150, height=100): im = Image.open(imgpath) im = im.resize((width, height), Image.NEAREST) # 裁剪 box = (0, 30, width, 70) # 这里的参数可以这么认为：从某图的(x,y)坐标开始截，截到(width+x,height+y)坐标 # 所包围的图像，crop方法与php中的imagecopy方法大为不一样 newIm = im.crop(box) txt = "" for h in range(newIm.size[1]): for w in range(newIm.size[0]): txt += select_ascii_char(*newIm.getpixel((w, h))[:3]) # 此处请看详解（1） txt += '\n' return txtdef save_as_txtfile(txt): with open('imgtochar.txt', 'w') as f: f.write(txt)def codeBegin(): print(output(imgpath)) save_as_txtfile(output(imgpath))def getCheckCode(image_get_url): im = requests.get(image_get_url) # 获取验证码和cookies值 with open('check_code.jpg', 'wb') as f: f.write(im.content) # img = Image.open('check_code.jpg') # img.show() codeBegin() check_code = input("code:") print("your input:" + check_code) return check_codedef login(): files = os.listdir('.') if 'cookies.txt' in files: with open('cookies.txt', 'rb') as f: cookies = requests.utils.cookiejar_from_dict(pickle.load(f)) bt_session = requests.session() bt_session.cookies = cookies try: torrent_url = 'http://bt.byr.cn/torrents.php' test = bt_session.get(torrent_url) if test.status_code != 200 or test.url != torrent_url: print('Something wrong when login in. Delete the cookies and relogin plese.\n') return except: print("net error") return else: username = input("your username:") password = input("your password:") login_php = 'http://bt.byr.cn/login.php' try: bt_session = requests.Session() req = bt_session.get(login_php) except: print("net error") return print(req.text) # &lt;input name="imagehash" value="2cb98173c9a2fc28f0976f9a5b715db5"&gt; imageHash = re.findall('name=\"imagehash\" value=\"(.*)\"/&gt;', req.text)[0] print(imageHash) image_get_url = 'http://bt.byr.cn/image.php?action=regimage&amp;imagehash=' + imageHash check_code = getCheckCode(image_get_url) login_post_url = 'http://bt.byr.cn/takelogin.php' login_datas = &#123; 'username': username, 'password': password, 'imagestring': check_code, 'imagehash': imageHash &#125; try: main_page = bt_session.post(login_post_url, login_datas) print(main_page.text) if main_page.url != "http://bt.byr.cn/index.php": print("login error") return with open('cookies.txt', 'wb') as f: pickle.dump(requests.utils.dict_from_cookiejar(bt_session.cookies), f) except: print("net error") return bt_sessionsession = login() 郑重声明：本系列文章提供的是在无ipv6环境下访问北邮人BT并且下载资源的一种方式，重在技术探讨，严禁使用本教程方法传播销售BT资源，否则造成的后果自负。在未获得作者本人许可之前不得将本文转载，转载请联系fuxuemingzhu#163.com（将#换成@)。 走心推广因为本博客部署在Digital Ocean 服务器上，每个月都要有5美元的成本，对于学生党来说也是不小开支。所以既然你能看到这篇博客的话，希望你能帮助我一下，鼓励我写出更好的文章。 Digital Ocean 服务器购买如果你也需要购买服务器，强烈推荐Digital Ocean，推荐原因如下： 基础套餐很便宜，每月最低5美元 服务器资源很给力，基础套餐配置是512MB内存，20GB的SSD硬盘，带宽不限制 可以搭建ShadowSocks，实现科学上网（特别实用！！） 支持ipv6，轻松解决校园网流量不够用的问题 我使用的是san francisco节点，搭建好ss之后，看油管1080p视频轻松无压力！！ 你如果使用我的这个网址注册Digital Ocean，你可以得到10美元的代金券，我也能赚到一点，就是这个链接：https://m.do.co/c/86d4e56f6c7a。 另外，如果你也是学生，有校园网邮箱，即可申请GitHub的Student Pack，免费送你50美刀的Digital Ocean代金券！地址是：https://education.github.com/pack/offers。 菜菜手绘坊菜菜手绘坊是我的姐姐在经营的一个手绘店铺，每一笔都是我的姐姐亲自画出来的。手绘坊里有很多风格可以选择，特别适合做头像，屏保，聊天背景等等！！甚至可以画好图之后做成手机壳，情侣T恤都是可以的！价格真的很便宜，可以加微信具体聊价格，绝对会让你惊喜！ 更详细的宣传可以看我的这篇文章：http://fuxuemingzhu.cn/drawing/ 店主微信和QQ：290885604 下面是暗黑风格的，看看有没有心动： 暗黑风格：]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的Hexo博客变得更酷炫]]></title>
    <url>%2F2017%2F08%2F12%2Fhexo-next-polish%2F</url>
    <content type="text"><![CDATA[最近有了审美强迫症，不仅让自己的Ubuntu变得很酷炫，还想把自己的博客变得更吸引眼球。调了两三天的博客，只为让博客变得更美。 记录一下我的调整的地方，也为了让大家更能看到我博客的亮点。 由于本博客使用的是Next主题，不同主题的调整方式可能略有不同。大家可以根据自己的主题进行模仿调整。 鼠标点击出现小心心 把love.js放到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swig 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码： 12&lt;!-- 页面点击小心心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 漂浮的颗粒背景你注意到了吗？你现在正在看的博客的的背景是很多漂浮的小颗粒。更重要的是，当你鼠标放到空白位置时，小颗粒会吸附到你的鼠标位置！特别有意思~ 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swig 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 颗粒漂浮背景 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 颗粒效果因为特别耗性能，故已关。如果想玩，可以点击：https://neveryu.github.io/ 关于添加居中模块A head full of fears has no space for dreams. 不需要使用html，在Hexo3中可以使用下面语句实现。 1&#123;% cq %&#125; A head full of fears has no space for dreams. &#123;% endcq %&#125; 根据是否是当前页面并修改浏览器标题栏当页面切换到其他网页的时候，浏览器会有改变哦！切换回来也会有变化~去试试吧~~ 找到 \themes\next\layout\_layout.swig 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码： 1&lt;script type="text/javascript"&gt;var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function()&#123;document.hidden?(document.title="负雪明烛在这里等你",clearTimeout(st)):(document.title="Got ya~~"+OriginTitile,st=setTimeout(function()&#123;document.title=OriginTitile&#125;,3e3))&#125;)&lt;/script&gt; 在Hexo中使用ECharts实现动态图表EChart图表库是百度推出的在线网络画图库。非常好用，比如下面这张图，注意，’利润’, ‘支出’, ‘收入’，这些标签是可以点击的哦！有交互效果！ // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts8581')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', itemStyle : { normal: { label: {show: true, position: 'inside'} } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', itemStyle: { normal: { label : {show: true} } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', itemStyle: {normal: { label : {show: true, position: 'left'} }}, data:[-120, -132, -101, -134, -190, -230, -210] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 如何在Hexo中使用ECharts请看我的另外一篇博客，讲的更详细：http://fuxuemingzhu.cn/2017/08/10/echarts-hexo/ 后续补充中……走心推广因为本博客部署在Digital Ocean 服务器上，每个月都要有5美元的成本，对于学生党来说也是不小开支。所以既然你能看到这篇博客的话，希望你能帮助我一下，鼓励我写出更好的文章。 Digital Ocean 服务器购买如果你也需要购买服务器，强烈推荐Digital Ocean，推荐原因如下： 基础套餐很便宜，每月最低5美元 服务器资源很给力，基础套餐配置是512MB内存，20GB的SSD硬盘，带宽不限制 可以搭建ShadowSocks，实现科学上网（特别实用！！） 支持ipv6，轻松解决校园网流量不够用的问题 我使用的是san francisco节点，搭建好ss之后，看油管1080p视频轻松无压力！！ 你如果使用我的这个网址注册Digital Ocean，你可以得到10美元的代金券，我也能赚到一点，就是这个链接：https://m.do.co/c/86d4e56f6c7a。 另外，如果你也是学生，有校园网邮箱，即可申请GitHub的Student Pack，免费送你50美刀的Digital Ocean代金券！地址是：https://education.github.com/pack/offers。 菜菜手绘坊菜菜手绘坊是我的姐姐在经营的一个手绘店铺，每一笔都是我的姐姐亲自画出来的。手绘坊里有很多风格可以选择，特别适合做头像，屏保，聊天背景等等！！甚至可以画好图之后做成手机壳，情侣T恤都是可以的！价格真的很便宜，可以加微信具体聊价格，绝对会让你惊喜！ 更详细的宣传可以看我的这篇文章：http://fuxuemingzhu.cn/drawing/ 店主微信和QQ：290885604 下面是黑白风格的，看看有没有心动： 黑白风格： 参考资料：Hexo-NexT搭建个人博客（二）]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现北邮人论坛模拟登录]]></title>
    <url>%2F2017%2F08%2F12%2Fbyrbbs-login%2F</url>
    <content type="text"><![CDATA[模拟登录北邮人论坛可能是每个学着写爬虫的北邮人必备技能了。在网上和论坛上也有相关资料，但质量参差不齐，有些甚至不能实现模拟登录。因此，这里我使用requests库和urllib2库两种方法，分别实现了北邮人论坛的模拟登录。 教程所需环境： Python 2.x requests 库 requests库模拟登录北邮人论坛教程的刚开始我们先优先使用最为方便的库:requests。 requests库的宣言是： HTTP for Humans （给人用的 HTTP 库） 通过使用可以看出，requests库确实是当前Python处理网络请求最好用的库！强力推荐大家放弃urllib2库！ 安装方式很简单： 1pip install requests 安装完成之后，可以用下面的代码测试是否安装成功： 1import requests 如果Python环境没有报错就说明安装成功，可以使用这个最方便的网络请求库了~ 下面我们开始分析模拟登录的逻辑。 首先，打开论坛首页https://bbs.byr.cn/#!default，并且退出登录。 然后，按F12键审查元素，并且切换到Network选项卡，并且勾选上preserve log选项。现在的状态如下： 重点来了，输入用户名密码后点击登录，你应该能看到下面的信息： 可以看出向https://bbs.byr.cn/user/ajax_login.json发送了一个post请求，发送了正确的用户名密码之后，就能登录成功。 另外，经过测试得到，如果请求的头部不正确，论坛会拒绝登录，正确的方式是添加头部。必须添加下面的头部。 1'x-requested-with': 'XMLHttpRequest' 下面是完整的登录代码，请输入自己的用户名和密码。 12345678import requestsr_url = 'https://bbs.byr.cn/user/ajax_login.json'my_header = &#123;'x-requested-with': 'XMLHttpRequest'&#125;byr_data = &#123;'id': 'fuxuemingzhu', 'passwd': '********'&#125;session = requests.Session()req = session.post(r_url, data=byr_data, headers=my_header)print(req.text) 运行结果，这说明运行代码执行成功： 123456789101112131415161718&#123; "id": "fuxuemingzhu", "user_name": "意涵团·负雪明烛 http://fuxuemingzhu.cn", "face_url": "https://static.byr.cn/uploadFace/F/fuxuemingzhu.120.jpg", "face_width": 120, "face_height": 120, "gender": "m", "astro": "未知", "life": 365, "qq": "", "msn": "", "home_page": "http://fuxuemingzhu.cn/", "level": "版主", "is_online": true, ...... "ajax_code": "0005", "ajax_msg": "操作成功"&#125; 这里有必要讲一下为什么使用了Session()的方式，这样可以使用时requests库能自动保存cookies到Session中，也就是说只要程序没关闭，就可以访问其他数据！ 比如，我们查一下超神的信息： 12quer = session.get("https://bbs.byr.cn/user/query/zc199102.json", headers=my_header)print(quer.text) 返回结果如下： 123456789101112131415161718&#123; "id": "zc199102", "user_name": "超byr||呐，你们的小企鹅~", "face_url": "https://static.byr.cn/uploadFace/Z/zc199102.502.gif", "face_width": 100, "face_height": 75, "gender": "m", "astro": "未知", "life": 365, "qq": "", "msn": "", "home_page": "", "level": "用户", "is_online": true, ...... "ajax_code": "0005", "ajax_msg": "操作成功"&#125; 根据这个原理你可以查看任意用户的公开信息，或者把整个论坛爬下来。 urllib2库模拟登录北邮人论坛urllib2库是Python自带的库，并且已经在Python3中取消。这就是我不再推荐的原因，另外下面冗长的代码也可以看出，这个库不好用。 urllib2库不支持自动管理cookies，需要导入cookielib包进行管理。因为登录的逻辑上文已经分析过，所以，这里直接贴上代码。 12345678910111213141516171819import cookielibimport urllib2import urllibauth_url = 'https://bbs.byr.cn/user/ajax_login.json'data = &#123;'id': '*********', 'passwd': '*********', &#125;post_data = urllib.urlencode(data)my_header = &#123;'x-requested-with': 'XMLHttpRequest'&#125;cookieJar = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookieJar))urllib2.install_opener(opener)req = urllib2.Request(auth_url, post_data, headers=my_header)b = opener.open(req)print(str(b.read()).encode('utf-8'))user_url = "https://bbs.byr.cn/user/query/zc199102.json"req_user = urllib2.Request(user_url, headers=my_header)a = opener.open(req_user)print(str(a.read()).encode('utf-8')) 执行后应该有和requests库同样的结果。 结语刚开始写这个模拟登录的时候还是个Python的小白，当时只会使用urllib2库，因为reqeusts库需要安装，所以就特别害怕去尝试新东西。 但是，尝试之后简直发现了新世界。requests库同时支持python2和3，这点就比urllib2方便。从上文的代码对比也能更加看出requests库的强大。 如果你没用过requests库，那么我强烈推荐你尝试，你会彻底抛弃urllib2的。 人生苦短，我用Python。如果你也在用Python，那么肯定像我一样希望节省更多的时间，因此，有更好用的东西就去尝试吧！不要害怕折腾。 走心推广因为本博客部署在Digital Ocean 服务器上，每个月都要有5美元的成本，对于学生党来说也是不小开支。所以既然你能看到这篇博客的话，希望你能帮助我一下，鼓励我写出更好的文章。 Digital Ocean 服务器购买如果你也需要购买服务器，强烈推荐Digital Ocean，推荐原因如下： 基础套餐很便宜，每月最低5美元 服务器资源很给力，基础套餐配置是512MB内存，20GB的SSD硬盘，带宽不限制 可以搭建ShadowSocks，实现科学上网（特别实用！！） 支持ipv6，轻松解决校园网流量不够用的问题 我使用的是san francisco节点，搭建好ss之后，看油管1080p视频轻松无压力！！ 你如果使用我的这个网址注册Digital Ocean，你可以得到10美元的代金券，我也能赚到一点，就是这个链接：https://m.do.co/c/86d4e56f6c7a。 另外，如果你也是学生，有校园网邮箱，即可申请GitHub的Student Pack，免费送你50美刀的Digital Ocean代金券！地址是：https://education.github.com/pack/offers。 菜菜手绘坊菜菜手绘坊是我的姐姐在经营的一个手绘店铺，每一笔都是我的姐姐亲自画出来的。手绘坊里有很多风格可以选择，特别适合做头像，屏保，聊天背景等等！！甚至可以画好图之后做成手机壳，情侣T恤都是可以的！价格真的很便宜，可以加微信具体聊价格，绝对会让你惊喜！ 更详细的宣传可以看我的这篇文章：http://fuxuemingzhu.cn/drawing/ 店主微信和QQ：290885604 下面是唯美风格的，看看有没有心动： 唯美风格：]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Hexo中我踩过的坑]]></title>
    <url>%2F2017%2F08%2F11%2Fhexo-wrong-I-found%2F</url>
    <content type="text"><![CDATA[为什么要开这篇文章？就是因为我这两天已经被Hexo折腾得够呛！ 诚然，Hexo一键部署博客给写作带来了很大的便利，但是不可否认的是，Hexo的错误让人摸不到头脑，只有反复尝试才能得出正确结果。 因此，奉劝大家，不要瞎升级Hexo！不要瞎改动Hexo！不要瞎折腾Hexo！ 这里记录下我踩过的各种坑，留给大家排坑，也方便自己以后查找问题。 Hexo升级3.0版本如果你现在用的是2.x版本，我强烈建议不要升级！因为大家用到的Hexo功能肯定都是简单的那几个命令，Hexo的2.x版本完全够用，升级很容易出问题！别问我为什么知道！ 如果你一定要升级的话，记住Hexo的3.x版本的安装命令是： 1npm install -g hexo-cli 昨天因为折腾，安装速度还很快，今天不知道为什么了，速度非常之慢，用了Hexo淘宝镜像也很慢。需要镜像的可以参考这个文章：修改npm包管理器的registry为淘宝镜像(npm.taobao.org)。 Hexo同时部署到多个Git仓库网上的教程很多，但是试了之后感觉都不行，会报错！亲测下面的方法可以用！ 在_config.yml中的deploy中这么写： 1234567deploy: - type: git repo: cfg@165.227.00.000:/var/repo/hexo_static branch: master - type: git repo: git@github.com:fuxuemingzhu/fuxuemingzhu.github.io.git branch: master 把仓库的地址修改成你的Git地址。 如果你使用的是Github的仓库，查看仓库地址的方式是在这里，记得切换成ssh模式查看。 Hexo文章中用相对路径方式插入图片这个坑大家可能都感觉遇到过，其实这不是个坑。 因为大家写博客就是公开的，完全可以把图片放到一个公开的图片网站再引用即可。但是我感觉不太好。 这种方式莫名其妙地把图片放到了一个你可能完全不会去访问的网站，很难管理，如果想删除图片也比较麻烦，甚至无法删除。 我之前的做法是放到自己的Github仓库中，然后引用自己仓库的图片的网址。这样不错，只不过图片要先上传一次，然后才能在博客里使用。 正确做法是在Hexo中采用相对路径方式插入图片。步骤如下。 首先在hexo目录下安装插件： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 然后，把打开_config.yml开关。这样新建每个文章都建一个同名的图片的文件夹，用于管理。 12_config.ymlpost_asset_folder: true 把图片放到文章的同名文件夹之下，在博客中用以下的hexo命令插入图片，注意不用填写路径，直接写图片名字！ 1&#123;% asset_img github.png github仓库地址 %&#125; 上面这个代码的结果就是上一节中github仓库的那张图片的代码。 这个是图片放的位置： 1&#123;% asset_img posts.png 图片放的位置 %&#125; 在public文件夹下会生成对应资源图片： 1&#123;% asset_img public.png 生成的图片 %&#125; 使用以上的代码就能看到效果了~ 更多信息可以看官方文档：资源文件夹 有得有失，这样做的时候就不能再markdown源文件中查看到图片了。 page页面图片不能采用相对路径博客的文章页面是可以采用相对路径寻找图片的，正如上文所述。可是，今天发现如果是一个page页面（可以通过侧边栏直接访问的），相对路径就不起作用了。。不是找不到图片的问题，而是如果是page页面采用asset_img的方式根本就不会识别出这里要插入图片。。 因此，解决的办法是直接采用markdown方式插入图片就好了，虽然有点不那么优雅…… 后续补充…… 参考资料： hexo博客图片问题]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Hexo的Next主题中使用ECharts画图工具]]></title>
    <url>%2F2017%2F08%2F10%2Fecharts-hexo%2F</url>
    <content type="text"><![CDATA[ECharts简介最近在实习的时候用到了ECharts。最刚开始我以为这个只能在前端通过js调用，对于我用python画图没帮助。可是自从再一次刷Github的时候发现了一个神器，激动地我差点睡不着了！这个就是pyecharts！这简直是神器啊，可以通过python调用ECharts的js接口然后就返回了画好的图~而且这个是可以交互的，比如下图，你就可以感受一下~~（利润，支出，收入三个标签也是可以点击的哦~） // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts3288')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', itemStyle : { normal: { label: {show: true, position: 'inside'} } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', itemStyle: { normal: { label : {show: true} } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', itemStyle: {normal: { label : {show: true, position: 'left'} }}, data:[-120, -132, -101, -134, -190, -230, -210] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 常规做法你可能也看到了，上面的图表在我的hexo搭建的博客中可以完美展示。这个是怎么做到的呢？ 首先，如果你用的是Yelee或者类似的主题，你应该可以很简单地直接参照这个博客去做。 我也是在看上面的博客的时候遇到了问题，如果我用Yelee主题的话是很简单的可以实现上面的效果的，但是我现在更喜欢的是现在的Next主题。这两个主题的结构不一样。 安装上文说的在所用主题目录下layout\_partial文件夹中不存在，更不存在head.ejs Next目录：Yelee目录： Next主题做法由此看出，如果你和我一样使用Next主题的话上面的教程不能用。需要像我这样做： 下载js首先下载ECharts的js文件：ECharts 把js文件放到next主题的\source\js\src目录下： js文件的引用然后在next\layout\文件夹下，找到_layout.swig文件，并用文本查看器打开，在下面代码: 1234567891011121314&lt;main id="main" class="main"&gt; &lt;div class="main-inner"&gt; &lt;div class="content-wrap"&gt; &lt;div id="content" class="content"&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% include '_third-party/duoshuo-hot-articles.swig' %&#125; &#123;% include '_partials/comments.swig' %&#125; &lt;/div&gt; &#123;% if theme.sidebar.display !== 'remove' %&#125; &#123;% block sidebar %&#125;&#123;% endblock %&#125; &#123;% endif %&#125; &lt;/div&gt;&lt;/main&gt; 的前面添加： 12&lt;!-- echarts --&gt;&lt;script type="text/javascript" src="/js/src/echarts.common.min.js"&gt;&lt;/script&gt; 保存退出。 安装hexo-tag-echarts插件在博客站点目录下执行npm install hexo-tag-echarts --save。 使用范例可以简单的找个例子试下，把下面代码放到一个博客的markdown文件中即可。注意不要使用代码块！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123;% echarts 400 '81%' %&#125;&#123; tooltip : &#123; trigger: 'axis', axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, legend: &#123; data:['利润', '支出', '收入'] &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis : [ &#123; type : 'value' &#125; ], yAxis : [ &#123; type : 'category', axisTick : &#123;show: false&#125;, data : ['周一','周二','周三','周四','周五','周六','周日'] &#125; ], series : [ &#123; name:'利润', type:'bar', itemStyle : &#123; normal: &#123; label: &#123;show: true, position: 'inside'&#125; &#125; &#125;, data:[200, 170, 240, 244, 200, 220, 210] &#125;, &#123; name:'收入', type:'bar', stack: '总量', itemStyle: &#123; normal: &#123; label : &#123;show: true&#125; &#125; &#125;, data:[320, 302, 341, 374, 390, 450, 420] &#125;, &#123; name:'支出', type:'bar', stack: '总量', itemStyle: &#123;normal: &#123; label : &#123;show: true, position: 'left'&#125; &#125;&#125;, data:[-120, -132, -101, -134, -190, -230, -210] &#125; ]&#125;;&#123;% endecharts %&#125; 之后你就应该能看到我的上面的ECharts图了。 最后上面的这个做法纯属我自己尝试得出来的，可能有更好的做法，可以在下面留言~~ 为了找到这个方法，我把自己的博客环境都搞坏了……现在在重装hexo……觉得我解决了你的问题的话就给我打个赏吧！ 参考文献： · echarts官网：http://echarts.baidu.com/ · Airing博客： http://blog.ursb.me/2016/04/06/Hexo%E9%A9%B1%E5%8A%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8Echarts%E5%8A%A8%E6%80%81%E5%9B%BE%E8%A1%A8/ · NeverYu博客： https://neveryu.github.io/2016/09/30/hexo-next-two/]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阔别许久，欢迎回来~~]]></title>
    <url>%2F2017%2F07%2F20%2Fwelcome-back%2F</url>
    <content type="text"><![CDATA[不知不觉已经离开一年多了，现在的我已经是准研究生一枚了，于是重新拾起了这个博客~~ 原来我去年就已经申请到了GitHub的student pack，这样的话我就能用了Digital Ocean的服务器50元的代金券，还有免费一年的.me的域名了。哈哈哈哈~~ 租了一台Digtial Ocean的服务器，成功的搭建了ss，现在通过ipv6访问外网的速度达到了12M/s，看国外视频都是1080p还不卡的，果然还是自己做来的比较爽呀，中间还学到了很多故障处理的方式。 之前租过两台服务器，分别是阿里云和腾讯云，但我都没用过……就在那里闲着感觉很浪费啊，这个DO服务器已经开始用来走ss啦，还是挺有用的，另外这个博客也是搭建在上面的。 顺便做个小广告吧，欢迎大家使用我的推荐码注册DO啊，这样你可以得到10美元的代金券，我也能赚到一点，嘻嘻，就是这个链接：https://m.do.co/c/86d4e56f6c7a 凡是使用上面这个链接注册DO服务器的，我教你怎么搭建SS科学上网~~ 喔喔，如果不想自己购买服务器还想畅快的科学上网的，直接给我发邮件，我给你开个账号也就行啦，费用好说好说~~ 欢迎大家来我的博客里赏光哈，如果想联系我，可以从导航栏里看到“关于我”就行啦~]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[首次面试经验总结]]></title>
    <url>%2F2016%2F04%2F19%2Flianjia-interview-experience%2F</url>
    <content type="text"><![CDATA[参加了一个面试，之后发现我的技术基本功完全就是渣！而且以前学过的都忘完了！回答的效果自己都感觉看不下去了。 不过还是感谢两位面试官能够花这么多时间和我交流。让我学习了很多。 别忘了，Show me the code! 下面就技术和知识两个方面进行分析。 技术篇提问： 面向对象的理解 抽象类和接口区别 接口能不能继承接口 重写 重载 重构 c++继承和java区别 面向对象的特性，多态的理解 四大组件 content provider和sqlite异同 自定义控件 View的继承关系，ViewGroup使用，和View的关系 设计模式 activity生命周期 js和android native相互调用 单链表翻转 c++对象调用父类方法 list.addAll(list1)，list1数据改了，list改不改 listAdapter中contentView复用，写出来 viewpager+fragment滑动时fragment方法调用状态 为什么用viewholder这种方式 主线程里面网络通信吗？数据怎么返回到主线程 你怎么搞多线程？ 网络请求用过哪些库，okhttp源码 java基础1.面向对象的理解？ 答： 1）符合现实抽象，便于理解：只是看类的名字你就可以猜到它有哪些方法了 2）良好的封装，减少了耦合性，同样减少了理解的成本：你不需要知道对你没有的信息 3）耦合性弱，聚合性强，因此可以很好地重用 4）可以很容易地进行功能的扩展（继承）和功能的修正（覆盖） 5）设计图确实好画很多了… 6）对于大型系统，可以比较地架构／设计，而不至于项目混乱 2.抽象类和接口区别？ 答： 参考：http://blog.csdn.net/chenssy/article/details/12858267 抽象类 抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….） 在使用抽象类时需要注意几点： 1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。 2、抽象方法必须由子类来进行重写。 3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。 4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。 5、子类中的抽象方法不能与父类的抽象方法同名。 6、abstract不能与final并列修饰同一个类。 7、abstract 不能与private、static、final或native并列修饰同一个方法。 接口 接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。 接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。 在使用接口过程中需要注意如下几个问题： 1、个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！ 2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。 3、接口中不存在实现的方法。 4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。 5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。 6、在实现多接口的时候一定要避免方法名的重复。 抽象类和接口区别 1.语法层次 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 12345678910111213public abstract class Demo &#123; abstract void method1(); void method2()&#123; //实现 &#125; &#125;interface Demo &#123; void method1(); void method2(); &#125; 2.设计层次 1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。 3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 总结 1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。 3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。 抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。只有对问题域的本质有良好的理解，才能做出正确、合理的设计。 3.接口能不能继承接口? 答：可以的。 抽象类可以继承抽象类，接口也可以继承接口。 抽象类继承测试： 123456789101112131415161718abstract class Parent &#123; abstract void teach(); void grow() &#123; &#125;&#125;abstract class Child extends Parent &#123; //不用实现teach()&#125;class Boy extends Parent &#123; //必须实现 @Override void teach() &#123; &#125;&#125; 接口继承测试： 123456789101112131415interface Fly &#123; void flySky();&#125;interface AnimalFly extends Fly &#123; //不用实现flySky() &#125;class Bird implements Fly &#123; //必须实现flySky() @Override public void flySky() &#123; &#125;&#125; 4.重写 重载 重构 答： 重构：就是代码优化，或则你可以理解为代码的修改！这并不是代码级别的行为，而是项目级别的行为。 例：开始你的类名是A现在要改为B也称为重构的一种 重载：发生在同一类中，方法名相同，参数个数不同、类型不同，返回值类型可以不同！（想一想JSON.paseObject(…)） 重写：发生在父子类中，子类中有一个方法名，参数列表和返回值类型与父类相同的方法完全相同时， 称之为方法重写 final这个关键字的用法。它的其中一个功能简单来说就是不允许子类对其进行重写，这是当我们在声明方法时使用它的时候的功效。而另一个功能则是在我们用它来声明变量或者字段时的功效，就是说这个变量或者字段的值不允许被修改。 有一次面试问我来着，问Listview怎么优化，我说ViewHolder，问那ViewHolder原理是什么，它优化了什么地方？然后我就蒙了，接着问ListView最消耗时间/性能的地方在哪，分别能怎么优化。。。都答不上来我就滚蛋了 5.c++继承和java区别 答：overide vitual 6.面向对象的特性，多态的理解 参考：http://blog.csdn.net/cancan8538/article/details/8057095 面向对象的三个基本特征是：封装、继承、多态。 封装 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。 多态 多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。 覆盖，是指子类重新定义父类的虚函数的做法。 重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。” 那么，多态的作用是什么呢？ 我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。 比如： 1List list=new ArrayList(); Android基础1.Android四大组件 参考：http://www.cnblogs.com/bravestarrhu/archive/2012/05/02/2479461.htmlhttp://www.cnblogs.com/bravestarrhu/archive/2012/05/02/2479461.html 上边这个博客是目前为止见到的讲得最详细的。 1、activity (1)一个Activity通常就是一个单独的屏幕(窗口)。 (2)Activity之间通过Intent进行通信。 (3)android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。 2、service (1)service用于在后台完成用户指定的操作。service分为两种： (a)started(启动)：当应用程序组件(如activity)调用startService()方法启动服务时，服务处于started状态。 (b)bound(绑定)：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。 (2)startService()与bindService()区别： (a)started service(启动服务)是由其他组件调用startService()方法启动的，这导致服务的onStartCommand()方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止。 (b)使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 (3)开发人员需要在应用程序配置文件中声明全部的service，使用标签。 (4)Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。Service组件需要继承Service基类。Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 3、content provider (1)android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。 (2)只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。 (3)ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。 (4)开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。 (5)ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。 4、broadcast receiver (1)你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 (2)广播接收者的注册有两种方法，分别是程序动态注册和AndroidManifest文件中进行静态注册。 (3)动态注册广播接收器特点是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕app本身未启动，该app订阅的广播在触发时也会对它起作用。 2.content provider和sqlite异同 答：这个没用过，可以试一试用。在上文的四大组件中能找到相关讲解。 3.自定义控件 答：没用过。是时候自己写一个了！！！这个很重要，每次都会问！！高手进阶必须会的！！ 参考郭霖大神的：http://blog.csdn.net/guolin_blog/article/details/17357967 4.View的继承关系，ViewGroup使用，和View的关系 答： 后来查了基本上是这么几个点： inflate XML因为涉及IO，是比较耗时的 findViewById()的原理是遍历XML布局找到指定ID，遍历耗时 图片加载耗时 解决办法： 利用convertView来避免重复inflate XML界面 利用ViewHolder保存Item内的引用避免重复findViewById()； 多用相对布局（如RelativeLayout）少用线性布局（LinearLayout）避免XML大量嵌套结构，加快findViewById()的速度 异步加载图片避免在getView函数内加载引起卡顿]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
        <tag>面试</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016.04 阶段性总结]]></title>
    <url>%2F2016%2F04%2F15%2Fparter-end%2F</url>
    <content type="text"><![CDATA[这是一份阶段性总结。虽然并没有明显的分界线，但我感觉过了这么久，总该写点什么吧，给以后的自己看。碰巧也遇到不少烦心事，闲着也是闲着，趁这种干不了其他事的时候自己反思一下自己罢。 这是篇给自己看的保留文章，完全是想到哪写到哪，特别没意思，游客止步吧。 回首这两个星期是大学生涯里边最忙碌的几天，这个星期是大学生涯里最悲催的一周，今天是大学生涯里最黑暗的一天。 大创这两个星期忙的最重要原因之一，大创。两个大创团队，是其中一个的组长，是两个团队里边唯一写代码的。 当时开始大创的时候，信心满满，企图通过最宏观的最前沿的科技来进行探索。当时的口头禅就是“别人能做的，我们就也能做”，一副天不怕地不怕的样子。不敢在公开场合大声讨论课题，生怕自己的课题被别人窃取。那段时间可能是整个大创过程中最有意思的一个阶段。 随着立项的开始，进度的安排，代码工作的开始，一切貌似有条不紊。我以为自己只有这么些事情，能很快做完，并且取得很大进展。确实在初期是这么快速的推进。 漫长的暑假，间间断断做了其中的很多工作，学习了很多新的设计和控件。也是那个时间不断拓宽自己视野，学到了很多新的知识。 艰难的大三上学期，所有的课程我都丧失了兴趣。没有一门课程能激发自己的兴趣，哪怕我认为这个学了有用。开始质疑自己为什么选择了自动化这个专业。大创放缓了脚步。队友妹子开始捉急，联系了我几次。 中期审核前，在导师带领下，我开始学习数据挖掘、机器学习。这又是一个非常充实的阶段。比着中科大熊辉教授的商业智能的课程，做了很厚的笔记。明白了很多新的数据挖掘的概念，当然并没有做任何项目练手，我也没有写代码进行数据挖掘的能力。这个期间感谢北邮认知交互实验室学长们的帮助，在Weka软件的帮助下，我大概能用已有的工具分析一些数据。更要感谢学长提供的某些有用数据，支撑起了我们后期整个大创。 中期审核是个痛苦的过程，答辩过程和审核老师们争论，确实老师们批评的对。这段时间，被队友们嫌弃。 中期审核之后，我彻底和队友们丧失了联系，所有大创工作全部我来做。因为我是这个组的组长，我还有一个负责人的老师，我要担起这个责任来。 保持每周五下午去认知交互实验室的节奏，因为每次都去，所以数据挖掘不停地学。感谢学长的带领和帮助，虽然真正茅塞顿开的时候并不存在，但是不可否定，在周期性的交流是对学习很有好处的。 大三愈来愈忙碌，渐渐减少了与实验室的联系，这里对不住老师了。 寒假，心里惦记着这个事。某女生队友在除夕前还在联系我，问我怎么办。是不是还要挣扎。作为队长，生性随和，我不会轻言放弃。我说，无论如何都要往后继续做，你别怕，有我呢。 年后难免在走动中度过一天天，说实话，大创一直是我的心事，惦记着，放不下来，也没法轻易解决。那么冷的天，我真没法一个人去做这个大创。期间做了些其他东西，下面可能会讲。 就这样，到了大三下，大创将近一年了。我没想到一年就这么过来了。 在进展基本为无的情况下，想着我是不是应该继续做啊。其中的一个项目需要用到音乐播放器，这段时间搜了Github上众多的开源播放器进行使用，但是，并不好用。当初的还是最好用的。这也很无奈，没有进度。 就这样恶劣的情况下，清明节之后，进行大创结题审核。我问了很多人大创怎么样了，要么没进展，要么放弃了！！左左右右看，大家也都是一样，没办法，再重的担子自己扛。 清明节出去玩了一趟，回来便开始做这个结题。鉴于进度不大，我只好做了很多文字工作，把之前做的工作都进行了整理，写了50页的文档，作为结项的依据。没有任何人帮我。我也没向任何人寻求帮助。最后我说时间抹不开，那个一直联系我的女队友能帮忙做ppt么？妹子很热心，让人很踏实，就去做了。 我一个人去找老师签字，老师批评了我，我感觉对不住老师。 ppt看了两遍就去上台讲，队友说有事来不了，不来就不来吧，反正都是我做的，也是我在讲，我也不管了。 很意外的，审核的老师并没有批评我们，这个比中期审核好的太多，老师给我们充分的肯定，我感谢各位老师的理解。 出门我跟队友讲，最近装逼技能max，装的逼多了，也就放松了、淡然了。队友幸福的样子。 这两天又是大创结项提交材料，马上要准备结项展示了。又是我一个人忙、我也不说什么。 过几天可能还有资料。我劳累的样子。 比赛比赛这事不适合公开来讲，但是我想来感谢一下队友，几位靠谱的学姐和一位学长。 学姐在论坛征友来参加比赛，我以为她们人手已经凑够，但是联系了一下，说我还可以加入。多么好的一个机会！我到现在都感觉那是我这段时间以来最正确的决定！所以说，万事不能怕联系，特别是有团队里有女生的时候。 第二天认识了三位靠谱的学姐，后来知道也是我们院的学姐。大四还在坚持参加比赛，这个精神值得敬佩。还有以为学长，是论坛大神，认识了也是极好的，学习了很多。 比赛就是不停的开会，不停地约时间。三位学姐是负责整个项目的，我和学长负责技术。她们三位辛苦了，不停地做方案，修改。当她们说三天三夜做了一个100多页的文档的时候，我也是震惊的不行，论文这么写的么？我还是第一次见。 前段时间才知道是她们在禧龙弄了三个通宵，我现在感动的不行。我一个做技术的，并没有完全按照她们的要求来，甚至有的时候都在尽量的少做开发，在写下这个的时候我有点自责。 过了预赛，进了决赛。她们为答辩做了很多，我真是算打酱油的。这个和普通的剧情不太合理，一般的剧情是除了技术，其他的人都在打酱油。 答辩现场，我们的答辩非常满意。赛后甚至还接受了主办方学校的采访。 结果是北京市第一名。再次感谢各位学姐、学长、指导老师对我一个学弟的照顾。 有几个比较悲剧的比赛，再此略过。 正是在这两周，尽力了、努力了的比赛的结果非常让人失望，我有点伤心。 黑暗上面两个讲了为甚么累，为什么悲催，这个应该讲为甚么今天是黑暗的。 可是，当伴随着半年的，无数个微信串起来的欢乐突然戛然而止的时候，我后知而后觉，所有都突然突然停止的时候…… 当下路还是要自己走。 放弃在T大某机器学习实验室呆了一个星期左右的时间，我并没有感到实验室是个非常轻松很长有意思的地方，不停的任务，不停的往前赶。更重要的是，没想到奇迹学习这么难。英文论文看不懂！！ 这段时间经常往清华跑，熟悉了整个学院路和成府路。对五道口那个地方也摸得非常熟悉了。最后我放弃了这个苦差事。太压抑了。完全不会还要逼自己读英文论文。我感觉自己适合做项目。 同时，论坛里有很多人私信，问我能不能合作，创业啊、实现非常酷的想法等等。我本来还有点兴趣，后来都拒绝了。真感觉太累并不是真正的好，放松一下自己，并不是在虚度光阴。 学校也有实验室接了项目想让我来合作，本来估计很简单的，但是考察了项目工作量之后，我感觉三个月也不一定能做完，更何况乱七八糟找的人，我也不放心。 最近这些事让我觉得或许真的让自己轻松下来，做一做自己想做的事情，陪一陪身边的人才是真正的生活。 心境清明节去十渡玩了两天，是个非常amazing的地方。真是风景如画。那么陡的山看的我心惊胆战，最后也都徒步爬了上去。 路上结交了很多朋友，他们都很友好。 微信加了好多新朋友。渐渐感觉自己已经完全脱离目前的生活圈子，进入社会了。 好多人认为我是研究生，还有人问我是不是女的，哈哈哈。 前方不敢说自己不迷茫。 实习投了不少暑期实习，从下周开始估计也要参加不少面试了。希望能有所收获。 另外，我一直做的一个青年人旅行的创业App（就是你想的那个），氛围非常好，估计会一直做下去。 学习这个确实是比较蛋疼的一个问题，是读研还是工作。我想如果还是我现在这么蛋疼的专业和学习不要也罢，但是研究生肯定不会这么苦逼。太严的实验室也不是很好，就像T大。这个等自己实习之后再说吧。 其他借楼征友。嗯 。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java读书笔记]]></title>
    <url>%2F2016%2F03%2F29%2Fjava-read-book-notes%2F</url>
    <content type="text"><![CDATA[Java必须知道的300个问题这本书是在图书馆随便逛的时候找到的书。花了一下午看完了，感觉有用的地方不是很多，大部分都是些概念，并没有太大用途。里边有些东西还是可以看一看的，总结如下。 当前写完这本书笔记的时间是：2016/3/29 19:52:26 Java语言基础1.表达式3-2.6==0.4的值？答：false。 这是有基本数据类型浮点数计算的不精确性造成的。 3-2.6=0.39999999999999999999.. 可以用BigDecimal进行浮点数精确计算。 2.&amp;和&amp;&amp;两个运算符的区别？答：&amp; 位与，&amp;&amp; 逻辑与。 3.不适用循环和条件语句如何求1+2+3+…+n？答：函数递归调用。 4.能正确编译”short s=1;s=s+1;”吗？答：不能。类型不匹配。可：s+=1； 5. += 计算结果一定正确吗？答：不。可能溢出。 6.两个整数相乘结果一定正确吗？不。 long num=2147483648.超出int范围，编译错误。 long num=214748364*10 结果为-10.int溢出。 long num=2147483648L*10 正确。 7.如何跳出多重嵌套循环？1234label:fori()&#123; break label;&#125; 8.存储相同数据量的一维数组和二维数组所占内存是否相同？二维数组远远大于以为数组。？？？ 9.只能通过构造方法构造对象吗？不是。 1Calendar c=Clalendar.getInstance(); 10.接口和抽象类的区别？1、抽象类可以提供成员的实现细节，而接口不能。数级抽象时如果要求提供成员的实现细节，可选抽象类。 2、如果涉及抽象时选择抽象类，在以后的版本中可以随意为抽象类添加新成员。而接口只有修改现有代码才能添加新成员。 3.一个类可以实现多个接口，但是能继承一个抽象类。如果要实现类似多重继承的效果，选接口。 两者相似，某些功能可以互换。但理念不同，抽象类用于继承，表示is-a；接口用于实现，表示like-a。 11.clone()方法的使用？1.浅克隆 被克隆的对象各个属性都是基本类型，而不是引用类型，如果存在引用类型的属性，则需要进行深克隆。 2.深克隆 如果需要克隆的饿对象的域包含引用类型，则需要使用深克隆；繁殖，可以直接使用Object类的clone()方法进行浅克隆。 12.两种方式可以实现深克隆，效率如何？1.序列化，效率很差。 2.榆次克隆各个可变的引用类型域的方式。 13.在内部类中调用外部类同名的成员？在内部类中调用内容类的x： this.x=… 在内部类调用外部类的X: TheSamName.this.x=… 14.反射？额，不会。。 字符串和包装类15.自动装包、拆包？基本数据类型自动转换成类.集合中不能存储基本数据类型。 123int a=3;arraylist.add(a); 16.String可以被继承么？不可以。final修饰的类不能被继承。 17.各种进制的转换123Integer.parseInt("101001010",2);二进制转intInteger.toBinaryString(int i);... Java集合类框架18.数组 和 集合的转换123List&lt;Integer&gt; list=new Arrays.asList(1,2,3,4,5);Interger[] array=list.toArray(new Integer[]&#123;&#125;); 19.Collection 和 Collections 的区别？Collection是集合类的派生接口。是Java集合类的基础。 Collections是为集合类定义的工具类，包含了一些查找排序的方法，非常实用。 20.获得Map中的全部键？Map接口中的keySet()方法 123Set&lt;K&gt; keySet()Set&lt;Integer&gt; keySet=map.keySet(); 然后通过键获得值。 21.获得Map中的全部值？12345values()Collection&lt;V&gt; values()Collection&lt;Integer&gt; values=map.values(); 22.获得Map中的全部键值对？1Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 异常处理23.throw和throws区别throws是方法里的声明要抛出什么异常 throw是抛出具体异常 I/O24.对象流？DataInput DataOutput 可以吧对象写入到磁盘中 但是读写的对象必须实现了Serializable接口。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>java</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信精选，每日精选微信优质文章App开发总结]]></title>
    <url>%2F2016%2F03%2F17%2FWeChoice%2F</url>
    <content type="text"><![CDATA[缘起微信精选的App开发来源是在聚合数据上看到了有免费的微信精选的数据接口，无限调用。相对于其他的诸如违章查询，医药查询，NBA赛事等等，我感觉还是微信文章精选这个数据接口离我最近，所以想着拿着个数据源练练手。 另外，有个笑话的接口我感觉还挺有意思的，也做成了一个APP，已经上线，可以在我的上一篇文章中看到详细的介绍。 雏形在这个App进入大家视野之前我已经做了一版，是用到了各方的库拼凑而成的，也实现了基本的列表、阅读文章的功能，里边的下拉刷新，加载更多，进度条都是用的不同方的，整体的结构感和风格太差。这也是我不是很满意的地方。 但就是在做上一个App——找乐，我发现了一个新的可以反复复用，结构明显，易于使用，风格统一的框架——Beam(Beam)。这个MVP结构的结构框架已经集成好了列表界面的刷新、加载更多、错误提示、进度提示等等，这用起来也太方便了！所以我花了一天的时间对之前写的应用进行了重构，删除了不少代码，并且使用了MVP模式的整个App结构看起来非常舒服。以后如果自己做App就用这个框架（求推荐其他的框架），开发效率大大提升。 这个是App重构后的样子： 本项目已经开源：https://github.com/fuxuemingzhu/WeChoice，欢迎Star和Fork。 开发这种类似新闻客户端的开发经验较少，在看了其他的客户端之后发现基本都差不多，那我就从简开发吧。 框架对于Beam框架，搭配上EasyRecyclerView，这样的MVP架构对生命周期的管理特别好，比如刷新、加载、错误提示、进度条等等，大家试用了这个微信精选App后可能也会有这样的感受，所有的东西展示不是那么突兀，显得很连贯，这要感谢框架的作者的贡献，也对大家推荐这个框架Beam. 估计这个框架可能节省了我开发项目的2/3的时间。 数据前文已经说了，使用的聚合数据的微信精选的接口https://www.juhe.cn/docs/api/id/147，其实对于这个接口不是非常满意，因为功能有点少嘛。但是无限制调用这个还是可以拿来练手的。 我开源的数据中没有把聚合数据的AppKey给公开，如果需要基于本项目改造的，请自行申请APPKey. 设计本来打算用CardView来实现卡片效果，但是发现CardView会自动设置为阴影效果和圆边，这样就要求数据之间要有间隙。但在Google的Material Design中，我的这种想法是不推荐的。 下图中，左边为推荐，右边不推荐： 理由是： Don’t. The use of cards here distracts the user from being able to quickly scan. These list items are also not dismissable, so having them on separate cards is confusing. 好吧，在我多次希望能通过调节Card之间的间隙达到比较满意的推荐效果时，发现做不到，好吧，那只有乖乖用普通的FramLayout了。效果大家也都看到了。 技术亮点双队列实现数据加载不重复 在找乐App中没有做这个功能，就是在下拉刷新的时候可以不停地更新数据。大家做开发的都明白，数据是按页返回的，一般下拉的时候默认的就请求了第一页的数据，因此数据基本都是原来的数据。在微信精选这个App中，我用了双队列——下拉刷新队列和上拉加载更多队列，来实现了这个记载数据不重复的问题。 道理很简单：记录下来已经加载的页数，下次想服务器请求的时候不去请求已经加载过的页，这样就可以实现数据不重复。 至于用队列，是因为聚合数据的数据页数有限（只有25页），我把下拉刷新队列存放的页数设置成了10，也就是说在下拉10次之内不会出现重复数据，第11次刷新的时候把对第一次放入队列的数字出列。上拉加载更多的页数设置为25，在25次上拉之后清空队列。 每次新数据的进入是使用的随机数的方式。嗯。 具体实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int morePages = 1;final int QUEUE_SIZE = 10;//队列大小//手写队列用来存储已经加载过的文章页数Queue&lt;Integer&gt; refreshQueue = new LinkedList&lt;&gt;();Queue&lt;Integer&gt; moreQueue = new LinkedList&lt;&gt;();int page = 1;@Overridepublic void onRefresh() &#123;super.onRefresh();if (refreshQueue.size() == QUEUE_SIZE) &#123; refreshQueue.poll();&#125;refreshQueue.offer(page);moreQueue.clear();moreQueue.offer(page);ChoiceModel.getInstance().getChoice(page, new DataCallback() &#123; @Override public void success(String info, ChoicePage data) &#123; getAdapter().clear(); getAdapter().addAll(data.getContentlist()); while (refreshQueue.contains(page)) &#123; page = (int) Math.ceil(Math.random() * 25); &#125; JUtils.Log("refreshQueue", refreshQueue.toString()); &#125; @Override public void error(String errorInfo) &#123; getView().showError(new Throwable(errorInfo)); &#125;&#125;);&#125;@Overridepublic void onLoadMore() &#123;super.onLoadMore();while (moreQueue.contains(morePages)) &#123; morePages = (int) Math.ceil(Math.random() * 25);&#125;if (moreQueue.size() == 25) &#123; moreQueue.clear(); moreQueue.offer(page);&#125;moreQueue.offer(morePages);JUtils.Log("moreQueue", moreQueue.toString());ChoiceModel.getInstance().getChoice(morePages, new DataCallback() &#123; @Override public void success(String info, ChoicePage data) &#123; getAdapter().addAll(data.getContentlist()); &#125; @Override public void error(String errorInfo) &#123; getView().showError(new Throwable(errorInfo)); &#125;&#125;);&#125; 解决WebView选择框弹出时将ToolBar下推问题 长按WebView中的文字，会弹出上下文选项，ToolBar会下推。如下图1。 参考了狐狸大神的文章：解决ToolBar在显示上下文菜单中被推下的问题 只是在AppTheme style中一行代码的事情： 1&lt;item name="windowActionModeOverlay"&gt;true&lt;/item&gt; 或者如下，根据安卓版本而不同： 1&lt;item name="android:windowActionModeOverlay"&gt;true&lt;/item&gt; 效果如下： 缺陷其实不满意的地方挺多的= =，这里主要说一下最不满意的地方，就是WebView这一块。加载文章详情的时候，这个原生WebView很不好用！ 很差的进度提醒机制 很差的错误识别与处理机制 很差的数据重新记载体验 无法查看大图 感觉每个都很影响体验，目前的实现非常不爽，代码看了代码之后就会知道我为了识别网页错误在多少地方做了监听处理。而且查看大图和下载也没有实现。 希望大家能给出好的WebView的封装框架，因为我一直没找到这方面的开源项目。 同时缺少了分享模块、搜索模块。 截图 下载 小米应用商店 应用宝 豌豆荚 Fir.im：http://fir.im/wechoice 二维码： （暂时只能通过Fir，其他的应用商店还在审核，应用宝审核已被打回两次。） 总结花了一整天对项目进行了重构，优化了一天处理界面、开源和本博客，时间其实还是没用很多的。再次感谢这个框架Beam，真是程序员的福音。 这个项目本来不打算开源的，但是我感觉用了框架之后自己写的东西就很少了，干脆开源。 但是本作者保留一切商业化的权利。 一切基于本项目的修改都必须开源，并且采用相同的开源协议。 好了，本项目的地址是：https://github.com/fuxuemingzhu/WeChoice，欢迎Star和Fork。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找乐，一个笑话App的制作过程记录]]></title>
    <url>%2F2016%2F03%2F15%2FFind-Joy%2F</url>
    <content type="text"><![CDATA[缘起想做一个笑话App的原因是因为在知乎上看过一个帖子，做Android可以有哪些数据可以练手，里面推荐了几个数据开放平台。在这些平台中无一不是有公共的笑话接口，当时心想这个可以拿来练手啊，还挺有意思的，估计还能积累一点用户。 碰巧（真的好巧）在Github中遇到了一个MVP设计模式的框架Beam，作者Jude95有一个笑话仓库————Joy（豆逼），就是一个做笑话的！更巧的是用到的接口也是我在关注的接口，心想不如改造一下吧，做个升级版，自己也可以在这个中学到别人是怎么写App的。后来发现这是一个非常正确的决定。 雏形因为是基于别人的改进，所以在写之前就已经有雏形，当然这个雏形不是很完善，这恰恰给了我修改的空间。在获得作者的修改同意后，我就进一步研究这个利用MVP框架书写的App。未修改之前： 首先，豆逼只能查看段子和查看图片，我认为基本的复制文本和查看大图以及下载图片，这些都没有。作者只是用这个仓库来说明MVP模式的，所以只做了最基本的功能。作者也说，笑话连个id都没有，点赞、评论什么的根本没法做。那好，我就把我认为的文本复制和图片相关的做一下吧。 研究MVP模式在这个项目之前我研究很少，只是听说，但是这个项目完全给我耳目一新的感觉，MVP对Android来说实在是太有用了！关于MVP我以后想仔细写个帖子研究一下，这里只想说明MVP使Android项目层次分明，代码结构简单，复用性高。参考作者的Beam。 这个项目用了很棒的一个开源控件，也是项目作者自己的控件EasyRecyclerView，这个控件对我来说相见恨晚。线性布局仿EasyRecyclerView已经实现了下拉刷新，上拉加载更多，错误提示等，简直把项目开发中可能遇到的坑都给做好了，我之前只能一个一个的去实现这些功能！为什么没有早早的用上这个控件！ 其他的没有重大的惊喜，但是项目总体感觉代码量很少，很精简。如果是我完成相同的功能的App，可能需要3倍的代码才能实现。 改进查看大图首先实现点击查看大图的功能。 PhotoView这个控件也是之前不久在Github中遇到的，使用的时候没想到竟然这么容易！只需要在xml中声明一个PhotoView，基本的放大、缩小、手势识别都有了！太方便！可能也是北邮人论坛官方客户端采用的一个查看大图的工具。 在java文件加载图片时则与ImageView完全相同，这个不在赘述。 还有一个拓展的地方是，单击图片返回（= = 一般都有吧？）。这个需要根据PhotoView的官方说明，使用Attacher来管理点击事件，经过我测试，貌似直接声明ImageView的点击是不会有效果的。 图片下载这个App采用的是Glide加载网络图片，而Glide并没有直接的下载存储的方法，只有自己拓展，耽误了些功夫。 直接分享一段图片下载和通知图库的代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142public void saveImage(String imageUrl) &#123;String[] names = new String[0];if (imageUrl != null) &#123; names = imageUrl.split("/");&#125;String imageName = names[names.length - 1];Glide .with(getView()) .load(imageUrl) .asBitmap() .toBytes(Bitmap.CompressFormat.JPEG, 100) .into(new SimpleTarget&lt;byte[]&gt;() &#123; @Override public void onResourceReady(final byte[] resource, GlideAnimation&lt;? super byte[]&gt; glideAnimation) &#123; new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; if (ImageStorage.checkifImageExists(imageName)) &#123; Snackbar.make(getView().fab, "图片已存在", Snackbar .LENGTH_LONG) .setAction("Action", null).show(); return null; &#125; String path = Environment.getExternalStorageDirectory().toString(); JUtils.Log("path", path); Bitmap bitmap = BitmapFactory.decodeByteArray(resource, 0, resource.length); JUtils.Log("imageName", imageName); ImageStorage.saveToSdCard(getView(), bitmap, imageName); Snackbar.make(getView().fab, "图片已下载", Snackbar.LENGTH_LONG) .setAction("Action", null).show(); return null; &#125; &#125;.execute(); &#125; &#125;);&#125; 其中ImageStorage.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ImageStorage &#123; public static String saveToSdCard(Context context, Bitmap bitmap, String filename) &#123; String stored = null; File sdcard = Environment.getExternalStorageDirectory(); File folder = new File(sdcard.getAbsoluteFile(), "FindJoy");//the dot makes this directory hidden to // the // user folder.mkdir(); File file = new File(folder.getAbsoluteFile(), filename + ".jpg"); if (file.exists()) return stored; try &#123; FileOutputStream out = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out); out.flush(); out.close(); stored = "success"; JUtils.Log("stored", stored); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 其次把文件插入到系统图库 try &#123; MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), filename, null); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; // 最后通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse("file://" + file .getAbsolutePath()))); return stored; &#125; public static File getImage(String imagename) &#123; File mediaImage = null; try &#123; String root = Environment.getExternalStorageDirectory().toString(); File myDir = new File(root); if (!myDir.exists()) return null; mediaImage = new File(myDir.getPath() + "/FindJoy/" + imagename); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return mediaImage; &#125; public static boolean checkifImageExists(String imagename) &#123; Bitmap b = null; File file = ImageStorage.getImage("/" + imagename + "" + ".jpg"); String path = file.getAbsolutePath(); if (path != null) b = BitmapFactory.decodeFile(path); if (b == null || b.equals("")) &#123; return false; &#125; return true; &#125;&#125; 为什么之前我试了很久但是一直发现图库没有图片呢？一直以为是自己的图片没有存储下来，后来用图库的查看文件夹的方式发现了FindJoy目录。 原来是需要通知图库更新，否则图片不会再图库中显示。具体请看上面代码。 复制段子这个本身是不麻烦的，出现问题的地方在于，这个MVP框架中怎么对这个List加上OnItemClilkListner。本身我就不很熟，这个地方犯了不少错误，我怎么没想到看EasyRecyclerView的官方说明呢？ 解决方法是在TextViewHolder中的itemView加上： 123456789101112131415161718itemView.setOnClickListener(view -&gt; new MaterialDialog.Builder(getContext()) .title(R.string.select) .content(R.string.copy) .positiveText(R.string.agree) .negativeText(R.string.disagree) .onPositive((dialog, which) -&gt; &#123; // Gets a handle to the clipboard service. ClipboardManager clipboard = (ClipboardManager) getContext(). getSystemService(Context.CLIPBOARD_SERVICE); // Creates a new text clip to put on the clipboard ClipData clip = ClipData.newPlainText("joy", data.getText()); // Set the clipboard's primary clip. clipboard.setPrimaryClip(clip); Snackbar.make(itemView, "已将该段子复制到粘贴板", Snackbar.LENGTH_SHORT).show(); &#125;) .show()); 官方库还有可以设置EasyRecyclerView的监听的方法，效果是一样的。 友盟统计友盟统计可能是我自己往外发包的一个必选的项了，因为要知道App的使用情况啊。这次发现友盟统计比以前好用多了，jar包也放到了jCenter()仓库，非常方便了。 这里要赞一下这个MVP库的好处了，竟然可以让所有的Activity的生命周期都调用同一段代码来实现友盟统计中要求的所有Actvity的OnResume()和OnPause()方法中都调用统计方法。 实现是通过一个顶级管理类MyActivityLifeCycleDelegate继承ActivityLifeCycleDelegate，在里面设置友盟统计的方法。 12345678910111213141516171819202122232425public class MyActivityLifeCycleDelegate extends ActivityLifeCycleDelegate &#123; public MyActivityLifeCycleDelegate(Activity act) &#123; super(act); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); JUtils.Log("onCreate" + getActivity().getClass().getName()); &#125; @Override protected void onPause() &#123; super.onPause(); JUtils.Log("onPause"); MobclickAgent.onPause(getActivity()); &#125; @Override protected void onResume() &#123; super.onResume(); JUtils.Log("onResume"); MobclickAgent.onResume(getActivity()); &#125;&#125; 然后在App的Application中声明： 1Beam.setActivityLifeCycleDelegateProvider(MyActivityLifeCycleDelegate::new); （话说上面这行代码是IDE自己简化的，好高端啊，竟然有点不明白是怎么回事了。。） 哦，对了，不要忘记在Manifest中声明友盟的appkey。嗯。统计就集成好了。 自动更新同样是友盟的服务，我也以为只是几分钟的事情就搞定了，可是因为自己的问题，耽误了一段时间，竟然还想着把这个锅扔给友盟。好吧，我错了。 这个和统计不一样的是需要手动下载包放到项目当中，其中包括了一个.so文件。 因为在app的gradle中声明了这句： 1compile fileTree(include: ['*.jar'], dir: 'libs') 我就以为万事大吉了。事实上我开启了友盟的debug模式才看了出来是我的.so没有加载进去。 嗯，jni应该这么声明，我给忘了： 12345sourceSets &#123;main &#123; jniLibs.srcDirs = ['libs']&#125;&#125; 这样.so文件就能加载进去了。而友盟自动更新只需要在MainActivity中写一句代码： 1UmengUpdateAgent.update(this); 很酷对不对？ 自动更新是根据app versionCode来判断的，更新的时候注意修改。 App截图这些功能做完之后我修改了一下配色，最终效果大体如图，部分功能未截图。 应用市场嗯，这些都实现了之后就上线应用商店了，主要有这几个： 小米应用商店：http://app.mi.com/detail/286105 应用宝：http://android.myapp.com/myapp/detail.htm?apkName=com.fuxuemingzhu.findjoy 豌豆荚：http://www.wandoujia.com/apps/com.fuxuemingzhu.findjoy Fir.im：http://fir.im/axy4 可以扫码下载： 应用宝下载： 豌豆荚下载： Fir.im下载： 尽量不要用Fir，因为Fir没有直观的下载数目统计，嗯。尽量通过正规应用商店吧。 下载这事还得大家捧个场。 结语虽然是一个非常简单的App，但是却包含着非常多的心思在里面，而且尝试新的东西的时候可以学到不少东西，这个是值得肯定的。毕竟我现在有种想把之前的App都揉碎重新来写的冲动，毕竟抵挡不住 MVP + Material Design的双重诱惑啊！ Android 开发还有很长的路要走。 本项目已经完全开源，代码在：https://github.com/fuxuemingzhu/FindJoy，欢迎Star和Fork.]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一个拥有大量结构相同Activity的项目精简经验，ReUsableActivity]]></title>
    <url>%2F2016%2F03%2F11%2FReUsableActivity-Using%2F</url>
    <content type="text"><![CDATA[简介一个可以重复利用的Activity.通过设置不同的Fragment加入到一个可复用的Activity中实现代码的精简。 这个仓库可以用来精简项目中拥有大量重复的AppBar布局的Android App。 介绍一直以来，大家对臃肿的Activity就不是很喜欢，都在试图减少Activity的数量，通过利用Fragment来实现代码的精简和提高运行效率。这个仓库就是设计了一个可以重复利用的Actvity，用填充Fragment的方式来进行代码精简。大大减少了Activity的数量。 同时，我承认这个只是一种重复利用的思想，至于更优雅的实现方式还请各位指教。 最后效果如下： 以下代码来获取通用Activity向外界展示的式样。fragmentType声明了加载哪一种Fragment,title声明了Activity应该显示的title. 1234567// 获取启动该Result的IntentIntent intent = getIntent();// 获取该intent所携带的数据Bundle data = intent.getExtras();// 从Bundle包中取出数据fragmentType = data.getInt("fragmentType");title = data.getString("title"); 以下代码来说明要加载的Fragment.是由传入的fragmentType来确定的。 12345678910111213switch (fragmentType) &#123; case 0: title = "空白界面"; fragment = new BaseFragment(); break; default: ///////////////////////////////////////////////////////// fragment = new TestFragment(); // 把参数传给fragment。 fragment.setArguments(data); break;&#125; 其他的交给ReUsableActivity来实现。即是由FragmentManager来管理。和普通的Activity中显示Fragment原理相同，因此不做详细介绍，可参见代码。 上面Demo的代码是在Fragment中点击向ReUsableActivity传参数用来显示title，同时新的ReUsableActvity向新的Fragment传数据用来Fragment的展示。 在实际利用中，在需要用ReUsableActivity时传递给ReUsableActivity参数并且打开此Activity即可。 上面的项目的结构如下，虽然有众多的Acitvity显示，但是代码中却只有两个Acitvity. 结语尽可能进行代码复用，来精简项目，这个是项目中的一个小小的经验，分享出来，希望大家能提供一个更好的解决方案。 项目已经开源，仓库在https://github.com/fuxuemingzhu/ReUsableAcitvity。希望大家指教。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件使用教程（三）—— NineGridImageView 展示图片]]></title>
    <url>%2F2016%2F03%2F08%2FAndroid-List-Recycler-NineGrid-Views-Using-3%2F</url>
    <content type="text"><![CDATA[引子上文讲到RecyclerView的使用，确实非常方便易用，而且样式多样，很灵活。但在图像展示时，经常有朋友圈和微博等9张图以内的图片展示需求，这时候，不是一个可以无限下滑的RecyclerVew能解决的图片显示问题。那就需要一个类似于GridView的，九张图显示控件。并且，这个控件应该能针对不同个数的图片都有很好的显示效果，使图片尽可能大的展示在特定空间区域之内，很荣幸能遇到这样的一个开源控件，NineGridImageView. NineGridImageView因为是一个比较新的控件，而且作者也已经开博讲解怎么使用，所以我不过多阐述如何使用，如有需求请转步作者博客http://laobie.github.io/android/2016/03/06/nine-grid-iamge-view-libaray.html来进一步了解。我来说一说我是怎么使用的。 使用： 1compile &apos;com.jaeger.ninegridimageview:library:1.0.0&apos; xml配置： 12345678910&lt;com.jaeger.ninegridimageview.NineGridImageView xmlns:app="http://schemas.android.com/apk/res-auto"android:id="@+id/ngiv_nine_grid"android:layout_width="match_parent"android:layout_height="match_parent"android:layout_margin="16dp"android:layout_marginTop="30dp"app:imgGap="4dp"app:showStyle="fill"app:singleImgSize="120dp"/&gt; 控件绑定： 12@Bind(R.id.ngiv_nine_grid)NineGridImageView&lt;String&gt; nine_grid; 适配器NineGridImageViewAdapter，其中不一定是String类型，可以修改（这也是我的代码弱项）： 12345678910111213141516171819private NineGridImageViewAdapter&lt;String&gt; mAdapter = new NineGridImageViewAdapter&lt;String&gt;() &#123;@Overrideprotected void onDisplayImage(Context context, ImageView imageView, String url) &#123; Picasso.with(context) .load(url) .into(imageView);&#125;@Overrideprotected ImageView generateImageView(Context context) &#123; return super.generateImageView(context);&#125;@Overrideprotected void onItemImageClick(Context context, int index, List list) &#123; super.onItemImageClick(context, index, list);&#125;&#125;; 获得图片资源的方法可以从本系列第一篇博文中找到，这里说明如何把资源加载到NineGridImageView。已知urls_list中放的是各个图片的地址。如下方式进行adapter加载和资源输入。 12nine_grid.setAdapter(mAdapter);nine_grid.setImagesData(urls_list); 至此，图片已经能够显示了，而且显示效果会根据图片的个数进行改变，来做到对图片的适配。效果如下： 可以看出本控件还是很方便易用的。 这是控件对item的监听的办法，需要在adapter中书写： 12345@Overrideprotected void onItemImageClick(Context context, int index, List list) &#123; super.onItemImageClick(context, index, list); Toast.makeText(context, "" + index, Toast.LENGTH_LONG).show();&#125; 思考提出一些小的质疑，就是很少见到给一个控件加载适配器和加载内容是放在两行代码分别进行的吧？如在常见的ListView中，我们一般这么写： 123adapter = new ListViewAdapter(ListViewActivity.this, urls);Log.i("urls", urls.toString());listview.setAdapter(adapter); adapter中加载资源，listview中设置adapter.如果数据有改变一般是这么写： 1adapter.notifyDataSetChanged(); 告诉适配器内容改变了，也就是说由适配器来管理数据。本控件中是以控件来管理数据，这样我感觉很别扭。也只能勉强接受。同时我并没有看到在NineGridImageViewAdapter或者NineGridImageView中有notifyDataSetChanged();等语法来声明数据改变，或许只能重新设置数据源。 还有好像在适配器中进行控件子控件的监听好像见到的也不是很多。大部分是在view中进行setOnItemClick()方法对吧？这个我也感觉挺别扭。 但总之，这个库还是很好用的，作为图片九宫格自适应的图片展示还是很可以考虑使用的。 感谢作者提供了这个库，希望后续还有更好的改进。 结语这是最常用的NineGridImageView的使用，项目已开源在：https://github.com/fuxuemingzhu/ViewAdapterTest，欢迎Star和交流学习。 下一篇我将讲解对ListView/RevyclerView/NineGridImageView的使用优化。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件使用教程（二）—— RecyclerView 展示图片]]></title>
    <url>%2F2016%2F03%2F07%2FAndroid-List-Recycler-NineGrid-Views-Using-2%2F</url>
    <content type="text"><![CDATA[简介在上一篇博文中，介绍了大家已经很熟悉的布局控件ListView，在这篇文章中，我将使用比较新、功能也更强大的RecyclerView. RecyclerView首先，要用这个控件，你需要在gradle文件中添加包的引用（配合官方CardView使用） 12compile &apos;com.android.support:cardview-v7:23.0.1&apos;compile &apos;com.android.support:recyclerview-v7:23.0.1&apos; 在actvity_recyclerview.xml文件中定义布局： 12345678&lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/rv_recycleview"android:layout_width="match_parent"android:layout_height="match_parent"android:clipToPadding="false"android:padding="2dp"android:scrollbarStyle="outsideOverlay"android:scrollbars="vertical"/&gt; 和ListView文章中类似的代码声明： 1234@Bind(R.id.rv_recycleview)RecyclerView rv_recyclerview;ButterKnife.bind(this); 对于RecyclerView需要进行LayoutManager的配置，这个是和ListView一样的线性显示： 1rv_recyclerview.setLayoutManager(new LinearLayoutManager(this));//这里用线性显示 类似于listview 获取数据的方法参考上篇文章ListView，或者直接查看我的开源代码库，在此不再赘述。下面介绍RecyclerView的自定义Adapter. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NormalRecyclerViewAdapter extends RecyclerView.Adapter&lt;NormalRecyclerViewAdapter.NormalImageHolder&gt; &#123; private final LayoutInflater mLayoutInflater; private final Context mContext; private List&lt;String&gt; list; public NormalRecyclerViewAdapter(Context context, List&lt;String&gt; urls) &#123; this.list = urls; this.mContext = context; mLayoutInflater = LayoutInflater.from(context); &#125; @Override public NormalImageHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new NormalImageHolder(mLayoutInflater.inflate(R.layout.item_image, parent, false)); &#125; @Override public void onBindViewHolder(NormalImageHolder holder, int position) &#123; Picasso.with(mContext) .load(list.get(position)) .into(holder.mPicture); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public static class NormalImageHolder extends RecyclerView.ViewHolder &#123; @Bind(R.id.picture) ImageView mPicture; NormalImageHolder(View view) &#123; super(view); ButterKnife.bind(this, view); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("NormalTextViewHolder", "onClick--&gt; position = " + getPosition()); &#125; &#125;); &#125; &#125;&#125; 这是效果： RecyclerView很方便的更改样式。这是设置成两个竖列的样式代码： 1rv_recyclerview.setLayoutManager(new GridLayoutManager(this, 2)); 图片展示不紧凑是因为宽和高的问题，在item_image.xml配置文件中修改宽和高如下： 1234567891011121314151617&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="2dp" android:foreground="?selectableItemBackground"&gt; &lt;ImageView android:id="@+id/picture" android:layout_width="match_parent" android:layout_height="200dp" android:cropToPadding="false" android:scaleType="centerCrop" tools:ignore="ContentDescription" tools:src="@color/primary_light"/&gt;&lt;/FrameLayout&gt; 这样就可以比较好的效果： 同样可以很简单实现瀑布流： 1mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, OrientationHelper.VERTICAL));//这里用线性宫格显示 类似于瀑布流 此时的item_image.xml为： 12345678910111213141516&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="2dp" android:foreground="?selectableItemBackground"&gt; &lt;ImageView android:id="@+id/picture" android:layout_width="match_parent" android:layout_height="wrap_content" android:scaleType="centerCrop" tools:ignore="ContentDescription" tools:src="@color/primary_light"/&gt;&lt;/FrameLayout&gt; 结果： 简单到很神奇。 这是最常用的RecyclerView的使用，项目已开源在：https://github.com/fuxuemingzhu/ViewAdapterTest，欢迎Star和交流学习。 下一篇将讲解九宫格图片布局NineGridImageView.]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件使用教程（一）—— ListView 展示图片]]></title>
    <url>%2F2016%2F03%2F07%2FAndroid-List-Recycler-NineGrid-Views-Using-1%2F</url>
    <content type="text"><![CDATA[起因最近在看一些开源项目时，经常看到了RecyclerView，这是安卓5.0推出的一个新的控件，可以代替传统的ListView，已经这么久了还没有用过，所以决定试一试。另外在做这个的工程中看到了另外一个九宫格的图片加载库，也顺便试用了一下。 ListView 使用首先，说一下ListView，这个是最常用的控件之一，大家都比较熟。这里自己简单记录一下。 这是目标结果，获取Gank.io上的妹子的图片地址并且进行获取展示。 首先，在xml配置文件中添加ListView的代码声明。 12345678&lt;ListView android:id="@+id/lv_listview" android:layout_width="match_parent" android:layout_height="match_parent" android:clipToPadding="false" android:padding="2dp" android:scrollbarStyle="outsideOverlay" android:scrollbars="vertical"/&gt; 布局之后的样子： 然后在ListViewActivity.java中使用ButterKnife进行控件绑定。 12@Bind(R.id.lv_listview)ListView listview; 记得代码中添加这句： 1ButterKnife.bind(this); 下面进行数据获取并且放到一个ArrayList中，我这里只存放了图片的地址，其实可以定义图片更多属性，进行存放。数据获取选用了张洪洋的Okhttp-utils，非常方便，可以学习。数据源是大名鼎鼎的gank.io中的妹纸们。接口免费调用，同学们还是节省点用。 123456789101112131415161718192021private String url = "http://gank.io/api/random/data/福利/20";OkHttpUtils .get() .url(url) .build() .execute(new StringCallback() &#123; @Override public void onError(Call call, Exception e) &#123; Toast.makeText(ListViewActivity.this, "网络异常，请稍后重试", Toast.LENGTH_LONG).show(); &#125; @Override public void onResponse(String response) &#123; if (response == null) &#123; Toast.makeText(ListViewActivity.this, "网络异常，请稍后重试", Toast.LENGTH_LONG).show(); return; &#125; display(response); &#125; &#125;); 返回数据格式如下： 12345678910111213141516&#123; "error": false, "results": [ &#123; "_id": "56cc6d1c421aa95caa707523", "_ns": "ganhuo", "createdAt": "2015-11-04T10:33:50.564Z", "desc": "11.5", "publishedAt": "2015-11-05T04:02:52.968Z", "type": "福利", "url": "http://ww4.sinaimg.cn/large/7a8aed7bjw1exp4h479xfj20hs0qoq6t.jpg", "used": true, "who": "张涵宇" &#125; ]&#125; 获得的数据需要放在ArrayList中： 12345678private List&lt;String&gt; urls;urls = new ArrayList&lt;&gt;();JSONObject result = JSONObject.parseObject(response);JSONArray jsonArray = result.getJSONArray("results");for (int i = 0; i &lt; jsonArray.size(); i++) &#123;JSONObject temp = jsonArray.getJSONObject(i);urls.add(temp.getString("url"));&#125; 对于ArrayList中的图片的展示，必须使用Adapter.首先定义xml文件item_image.xml： 12345678910111213141516&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="2dp" android:foreground="?selectableItemBackground"&gt; &lt;ImageView android:id="@+id/picture" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="fitCenter" tools:ignore="ContentDescription" tools:src="@color/primary_light"/&gt;&lt;/FrameLayout&gt; 再在Adapter中进行代码解析，下面代码只是可用的水准，有改进空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ListViewAdapter extends BaseAdapter &#123; private final Context context; private final LayoutInflater inflater; private List&lt;String&gt; urls; public ListViewAdapter(Context context, List&lt;String&gt; urls) &#123; this.context = context; this.inflater = LayoutInflater.from(context); this.urls = urls; &#125; @Override public int getCount() &#123; return urls.size(); &#125; @Override public Object getItem(int i) &#123; return urls.get(i); &#125; @Override public long getItemId(int i) &#123; return 0; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ViewHolder viewHolder = null; view = inflater.inflate( R.layout.item_image, null); viewHolder = new ViewHolder(); viewHolder.imageView = (ImageView) view.findViewById(R.id.picture); String url = urls.get(i); Log.i("url", url); Picasso.with(context) .load(url) .into(viewHolder.imageView); ViewCompat.setTransitionName(viewHolder.imageView, url); return view; &#125; public class ViewHolder &#123; public ImageView imageView; &#125;&#125; 最后进行ArrayList中的数据和Adapter进行绑定，即可展示： 123adapter = new ListViewAdapter(ListViewActivity.this, urls);Log.i("urls", urls.toString());listview.setAdapter(adapter); 上述的数据获取和展示，我封装了一下为以下函数： 1234567891011private void display(String response) &#123;JSONObject result = JSONObject.parseObject(response);JSONArray jsonArray = result.getJSONArray("results");for (int i = 0; i &lt; jsonArray.size(); i++) &#123; JSONObject temp = jsonArray.getJSONObject(i); urls.add(temp.getString("url"));&#125;adapter = new ListViewAdapter(ListViewActivity.this, urls);Log.i("urls", urls.toString());listview.setAdapter(adapter);&#125; 这个函数利用了fastjson解析数据，response中的数据无论多少个，都可以快速解析并展示。 至此，网络数据的获取和在ListView中的展示全部完成，不得不说非常简单方便。 结语这是最常用的ListView的使用，并没有多少新意，项目已开源在：https://github.com/fuxuemingzhu/ViewAdapterTest，欢迎Star和交流学习。 下篇对RecyclerView进行测试使用。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>经验分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win8/Win10 Ctrl+Alt+方向键 屏幕显示翻转解决办法]]></title>
    <url>%2F2016%2F03%2F03%2FSolve-Win10-Screen-Rotation%2F</url>
    <content type="text"><![CDATA[状况Win10系统下，在Android Studio中使用快捷键 Ctrl + Alt + ↓ 复制代码段的时候神奇的情况出现了，屏幕显示倒转了，我也只能是一脸懵逼，Win7下没有这个问题。经验判断是AS的快捷键和Win10快捷键冲突了。回复正常的屏幕的方向的方法是快捷键 Ctrl + Alt + ↑ ，下面解决这个冲突。 解决方案首先 按 Ctrl + Alt + F12 进入以下管理界面： 点击选项和支持，在以下界面点击禁用快捷键。 应用退出即可。 这次再按 Ctrl + Alt + ↓ ，发现屏幕不再旋转，问题解决。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于阿里云 Ubuntu 的 LAMP 网站搭建及配置完全教程]]></title>
    <url>%2F2016%2F03%2F02%2FMy-Aliyun-Server-Setting%2F</url>
    <content type="text"><![CDATA[起因最近老师让我做一个众筹系统，可以在微信公众号上展示运行的。虽然说着简单，但是实现起来却完全不是那么回事，并且我一个做安卓开发的，对服务器和前端完全不懂，这个对我来说一路坎坷，最终上线，这里记录一下我的辛酸历程。 最终效果是在自己的网站服务器网页中运行以下网站： 经过服务器首先，当然要有一台云服务器，在腾讯云和阿里云当中，学生包的价格分别是1元每月和9.9元每月，这里我选择了阿里云，因为我感觉阿里云用的更多，应该更可靠点（想太多了，我这种小白用户感觉不到差别好么）。在使用阿里云的过程中还是感到了使用阿里云是更简单的，首先实名认证部分只需要绑定支付宝就能完成，学生认证需要输入学号和身份证号和学信网信息一致即可。腾讯云需要本人手持学生证拍照上传，这些略去不提。 域名再者，需要一个域名。当然这个不是必须的，因为只有云服务器ip也能访问服务器上运行的网站。当然我还是买了一个http://www.fuxuemingzhu.com/,这个域名现在是我的博客站点，并不是用来给服务器用，因为我的博客是存储在github.io的，这样写博客的时候还能增加github的contributions……这个域名需要备案和审核，采用的是阿里旗下的万网备案，如实填写，提交各种信息之后有个人工电话审核，接听了之后也只是有个住址信息不完整，帮我完善了下信息，最后阿里送了块幕布，拍照上传之后给工信部备案，总共大概20天左右域名到手。 前端和后台系统选择这两个完成之后，我也就啥都不会了……咳咳，但不能放弃不是，我知道需要前端和服务器配合，本来想按照学姐画的草图用DreamWeaver慢慢画吧，可惜自己水平不是一般的差，完全不会弄。经学姐提醒，可以搜类似网站代码啊，在搜的过程中，我找到了一个RaiseDreams的开源众筹系统！对呀，直接用开源写系统不就完了！看来程序员一般都是想着自己动手，没想到人家已经有免费的直接用就完了。 几经对比，我最终选择了芝麻乐开源众筹系统https://www.zhimale.com/，开源版本，永久免费，顺便也给人家打一个广告。我感觉这个系统唯一的不足就是帮助文档太少，可能对于我一个新手帮助不够吧。 软件安装我的阿里云服务器运行的是Ubuntu，正好我的电脑也有Ubuntu，所以，就先在本地搭建服务器试用吧。下面进入正式讲解。 首先，需要安装一个Apache，在放狗搜的时候发现了LAMP(Linux-Apache-MySQL-PHP)这个东西。对呀，一次性安装齐全多好！在Ubuntu的官方网站上有教程https://help.ubuntu.com/community/ApacheMySQLPHP。对我来说只需要一行命令（软件更新速度慢，没用）： 1$ sudo apt-get install lamp-server^ 不要忘记最后的 ^ 号。 Ubuntu好啊，一行命令就完成了所有的安装，这在Windows下不可想象。中间有一个对MySQL的密码的设置，设置好一定要记住！ 等运行结束之后就全部完成了！ 测试Apache，在浏览器输入 127.0.0.1 或者 http://localhost/ ,这个时候不能挂代理。如果出现 It works! 的画面，说明Apache安装成功。 下面检验PHP是否安装成功。在 /var/www/html 文件夹之下新建 testphp.php，打开写入以下内容： 123 &lt;?php phpinfo(); ?&gt; 如果用gedit无法编辑保存 testphp.php ，说明该文件为只读模式，请安装vim，并使用以下命令： 1sudo vim /var/www/html/testphp.php 在vim模式编辑模式下编写，关闭时要使用强制执行： 1:wq! 应该就可以了。如果还是不行可以采用 chmod 改变文章读写权限再试。（我忘记了我用哪种方法成功的了） 然后再在浏览器地址栏输入：http://localhost/testphp.php，出现如图所示内容表示PHP安装成功！ 因为芝麻乐系统需要用到php-gd，所以采用以下命令安装。不需要的请不要安装。 1234567# apt-get install php5-gd```java或者```shell$ sudo apt-get install php5-gd 并且重启狗帕琪。 1# sudo /etc/init.d/apache2 restart 至此，所有软件的安装已经结束。还是很简单的吧？ 软件配置软件安装过程中会自动生成 /etc/apache2/ 和 /var/www/ 文件夹，这两个基本是我们最重要的设置地方。其中 /etc/apache2/ 是apache的自身设置文件夹， /var/www/ 是要展示的网站的文件夹。其中 /etc/apache2/ 的文件夹目录如下： 可以看到 /var/www/ 只有一个被锁定的只读的文件夹 /html ，这里的文件必须用 sudo 命令打开，vim 编辑退出时使用 :wq! 命令。 下面设置自己的服务站点，并让其能在自己的网页上显示出来。 在 /var/www/ 文件夹下新建www.test.net的文件夹，并将开源网站所有代码和文件放入到其中，效果如图。 下面修改apache的路径指向www.test.net的文件夹。使用以下命令进行编辑。 1$ sudo vim /etc/apache2/sites-available/000-default.conf 将其中的ServerName取消注释，并将DocumentRoot修改为 /var/www/www.test.net，并使用 :wq! 命令保存关闭vim. 重启Apache: 1# sudo /etc/init.d/apache2 restart 如果没有问题的话就已经进入了芝麻乐重酬平台开源系统的安装界面了。按照芝麻乐的官方教程来做，应该很快就能安装成功。 官方教程网址：https://www.zhimale.com/News/show/id/8.html 至此，芝麻乐开源众筹系统已经在本地的Ubuntu上安装成功。 服务器配置本地安装一切顺利，可是没想到服务器上安装同样的东西却状况连连。 怎么连接服务器？采用阿里云推荐方式，Windows下安装盘putty，使用这个来与运行在阿里云上的服务器进行通信和命令传输。参考www.putty.org 怎么把文件传送到服务器？经过一番搜索，我采用在服务器搭建ftp系统，然后用ftp传送的方式。这里使用 vsftpd，安装和配置过程略去不讲，参考//TODO 和 http://jingyan.baidu.com/article/67508eb4d6c4fd9ccb1ce470.html。 这个配置是挺麻烦的，因为服务器上的文件是可以ftp给大家看的，如果没有做到充分地保障的话，服务器可能被大家搞得一塌糊涂，需要花点功夫好好折腾一下。 Windows上安装FileZilla，这样可以连接到服务器ip，注意端口为21. 将Windows下的芝麻乐平台代码进行上传，如果出现530错误，说明vsftpd设置的文件夹没有写入权限，需要使用以下命令改变文件夹的写入权限。 1# sudo chmod 755 /home/sftp/ 上传成功之后进行文件夹复制，使用以下命令。 1# sudo cp /home/sft/ /var/www 文件复制参考：http://zhidao.baidu.com/question/63755445.html 如果失败的话，同样是因为文件夹权限的问题，记得使用chmod改变/var/www/文件夹的写入权限。 这样之后，就成功把系统放入到了要配置的目标文件夹。下面配置Apache指向这里的文件夹。 1$ sudo vim /etc/apache2/sites-available/000-default.conf 将其中的ServerName取消注释，并将DocumentRoot修改为 /var/www/sftp，并使用 :wq! 命令保存关闭vim. 注意：上面的这些过程中如果出现错误一般就是读写权限的问题，出现错误之后注意修改文件夹的写入权限。 重启Apache，理论上已经可以用了，浏览器直接输入服务器的网址就行。 遇到问题怎么办？这时候如果出现关于ServerName的警告： Restarting web server apache2 apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName 那么请在 /etc/apache2/apache2.conf 中添加： 1ServerName localhost 重启Apache，这个警告就会消失。 可是我的服务器给我了500的错误，这个是怎么回事呢？为什么本地运行没出现这个问题？而且没有显示错误日志。 本以为是PHP安装没成功，但是搜索一番之后，受到启发，可以开启PHP的错误提示，然后进行分析。开启PHP错误提示的方法参考：http://tsov.net/open-ubuntu-php-error/ 123sudo chmod 777 /etc/php5/apache2/php.inisudo vim /etc/php5/apache2/php.ini 搜索并修改下行，把Off值改成On display_errors = Off 这就完成了，重启Apache。 这次服务器网页上会出现错误提示了，如下： Unknown: failed to open stream 经过搜索，参考以下网页http://stackoverflow.com/questions/5326531/php-warning-unknown-failed-to-open-stream，我推断是因为文件夹的读写权限导致。这个很奇怪，为什么读权限的文件夹不能在Apache上？这个我没有深入研究。那么下面的问题是修改 /var/www/ 文件夹下的文件的写入权限，把文件夹的用户切换到我的用户名root。 12345cd /var/wwwsudo chown www-data:www-data * -Rsudo usermod -a -G www-data root 重启Apache。 这次已经出现了芝麻乐的开源系统安装引导，按指导进行安装就能成功啦！ 结语至此安装已经完全成功，中途遇到了很多问题，最终都在强大的Google的帮助下解决。上面的文章虽然写到的遇到的问题的内容篇幅不多，但是却花了我两天的时间。中途学到了很多东西，也让我对服务器的使用更加熟练。 另外，我在遇到问题的时候并没有完全当时截图，后来写文章时有参考别人，另外命令不保证完全正确。 参考文献用到的文章在文章当中基本上都写了，在此表示感谢。 部分图片来自网络。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近感动到哭的一首歌《History》]]></title>
    <url>%2F2016%2F03%2F01%2FSong-History%2F</url>
    <content type="text"><![CDATA[第一次在油管上听到小破团的《History》的时候，我并没有太在意，只是感觉很好听。当某次看到这个MV的时候，看到四个人朴素的着装站在一面破旧的砖墙前毫无拘束、任性自由的手舞足蹈，画面中穿插着他们从出道来的成长和一起玩耍的黑白画面。这画面太朴素，但从刚出道时的五个小嫩肉到现在的四人组合，这转折让我怎么也不能平静下来。 想必大家都是以一首《What makes you beutiful》开始了解的One Direction，从开始听他的歌到不久前大概一年多的时间里，我只喜欢他们的这一首歌。除此之外对他们的了解只限于哈卷和泰勒情感故事，我并不喜欢哈卷，总是感觉他有点颐指气使，处事傲慢。 上一次注意到关于他们的新闻就是渣Zayn离团事件，这可能是关注欧美圈以来歌手里面比较震惊的事件。和大家一样，我不能想象出来少了一个歌手的乐队怎么继续走下去，他们将以什么的面貌继续出场，甚至怀疑他们是否从此一蹶不振、土崩瓦解。 看来我还是错了，小破团的最新专辑一改之前颓靡之风，歌词积极向上，乐调欢快顺口，开始走上了正能量的道路，因此我也更加喜欢他们最近的作品，如《Drag me down》，《Perfect》等。 《History》正是把我们对这些的感慨化为乐符，回忆起自己以前的朝夕相处的朋友，他们唱到： You and me, got a whole lot of history We could be the greatest team that the world has ever seen You and me, got a whole lot of history So don’t let it go, we can make some more, we can live forever 他们向全世界唱出了“请不要离开，我们可以成为最好的组合”的时候，有谁不为他们感动到cry呢。 看到他们当初那么青涩，现在的他们已经对整个现场把握的很到位，他们完全都是在放松的玩耍的状态录制MV，感觉他们已经完全习惯于彼此，融为一个整体了。 盛筵难再啊，四人组合唱出了对以前的兄弟的最真挚的表述，再想起以后的自己和我现在熟悉的这些人也最终是会像他们一样的分开，或许我们还能在一起高唱最喜欢的歌？ Baby don’t you know 難道你不知道嗎？ Baby don’t you know 難道你不知道 We can live forever 我們可以成為永恆 附上油管链接：https://www.youtube.com/watch?v=yjmp8CoZBIo]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影《无人区》]]></title>
    <url>%2F2016%2F02%2F29%2FNo-Man-s-Land%2F</url>
    <content type="text"><![CDATA[导演: 宁浩 编剧: 述平 / 邢爱娜 / 崔斯韦 / 王红卫 / 尚可 / 宁浩 主演: 徐峥 / 黄渤 / 余男 / 多布杰 / 王双宝 / 更多… 类型: 剧情 / 犯罪 / 西部 制片国家/地区: 中国大陆 语言: 汉语普通话 / 陕西方言 / 甘肃方言 上映日期: 2013-12-03(中国大陆) 片长: 117分钟 又名: No Man’s Land / Western Sunshine 寒假在家闲看的一部片子，没想到感触这么深。 本以为国产电影都是些西里古怪，恶搞做作的荒诞制作，结果这个片子一改我对国产电影的看法。 首先电影名字就是个双关，开头和结尾正好对应了它的两个意思，即原本无人的区域和最终无人的区域。里边的荒诞故事是有一些无厘头，但是正是这么多的巧合和矛盾冲突才构成了这个电影真正要表达的对人性的考验。 儒教说“不欺暗室”、“不愧屋漏”，只有在这周围没有任何人的情况下才能把人的本性才会真正的表现出来。电影通过这种完全放纵情况下的人物的表现来塑造了一个离奇而又惨痛的故事，也感谢各位演员把这个故事表现的有血有肉。 “人和猴子的区别就在于人会用火”，人如果不在本性最放荡的时候“玩火”，人可能也不会有这么多麻烦，也不会解决掉这么多麻烦。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello LaTeX]]></title>
    <url>%2F2015%2F12%2F18%2FHello-LaTeX%2F</url>
    <content type="text"><![CDATA[起源最早听说LaTeX是在做数据挖掘的熊辉老师公开课上，当时他说他看别人投过来的论文时，如果用Word写的，直接Pass，用”LaTeX”的才看。当时没有字幕，我愣是听了好几遍才根据发音把”LaTeX”这个词给拼了出来，搜索了相关资料。后来了解到了中国化之后的CTeX。 自从接触到这个词之后才感觉周围到处都是在讲LaTeX（可能是我之前没注意），学校里也有大神用LaTeX写毕设论文，恰巧我又在看美赛建模的一些经验，里面也有人提到了LaTeX，总之，LaTeX对我来说越来越具有吸引力。 经过当然首先是下载安装了。这本应该是最简单的一步，结果让我整了好久才弄成功。 对于CTeX，在其官方社区http://www.ctex.org/HomePage上给了百度网盘的下载地址。是我不小心，把所有的历史版本的CTeX都下载了下来，当然我发现下的不对，暂停了下载，只下载了最新的CTeX2.9。 讲一讲在安装时遇到的问题。 第一个，CTeX安装会覆盖系统环境变量，这个太坑爹，还好我提前做了备份。 第二个问题，第一次安装之后发现不好使，具体表现是WinEdt打开新建文件编译有问题，命令行的提示是“系统找不到相关文件”。我以为是下载的时候没现在完整（文件夹里还有.download文件），于是把CTeX2.9的Full版本给卸载重装。仍然同样问题。以为是没有字体库，安装上了，仍然不好使。卸载了重新装基本版本。仍然不好使。这个时候我就不淡定了，以为是CTeX的锅，打算装原版LaTex，反正美赛建模于是用纯英文写作。百度呀、Google呀、论坛呀都没搜到相关问题的答案，我感觉是我电脑的问题，或者我下载了盗版，我不会是唯一一出现这个问题的吧。 今天下午水论坛，发现一个人也是请教CTeX的问题，当然问题和我的问题不一样，但帖子底下有条回复是让楼主去CTeX的社区去问。这就提醒我，在一些技术性比较强的场合，自己专门的社区很可能比百度后者Google上其他人的经验内容要丰富。在CTeX社区搜索真发现了类似问题的帖子。逛了两个帖子之后找到了解决方案。 我试了一下，再次打开WinEdt就完全正常了！ 这个莫名其妙的错误困扰了我两三天。另外这个其实也发现是我们论坛的好哇，说不定哪个贴子就可以启发自己的思路找到正确结果。 使用方法： 我用的是XeLaTeX编译。然后点击放大镜查看pdf. 上几个小栗子。 1234567\documentclass&#123;article&#125; \author&#123;My Name&#125; \title&#123;The Title&#125; \begin&#123;document&#125; \maketitle hello, world % This is comment \end&#123;document&#125; 运行结果： 挺漂亮的吧。 中文示例： 1234\documentclass&#123;ctexart&#125;\begin&#123;document&#125;你好，世界\end&#123;document&#125; 结果： 图片示例： `latex\documentclass{article} \usepackage{graphicx}\begin{document} taylor.jpg \includegraphics[width=4.00in,height=4.00in]{taylor.jpg}\end{document}`latex 结果： 结语LaTeX虽然不是一项必须的技能，但是我感觉是一个写文章的很好的方式。当然Word的所见即所得令人爱不释手，但是对于专业论文的书写，LaTeX有它天生的优势。新技能，get。 参考文献CSDN:LaTeX新人教程，30分钟从完全陌生到基本入门]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组竟然是对象]]></title>
    <url>%2F2015%2F12%2F15%2Farrays-are-objects%2F</url>
    <content type="text"><![CDATA[起源事件起源是论坛里的一篇帖子，关于数组的.lenth多次调用是否会影响效率，回帖中发现有人说数组是类，调用类的.lenth属性就是看一下值，速度不会慢，云云。然后我就非常不同意的问人家“数组是对象？”，其实有点故意挑毛病的味道，但正是我这句话引起了论坛里较真的同学们的批判，事实证明，我错了，数组就是对象。 经过论坛里同学也给出了比较合理的反驳理由，就是下面这张图： 已经比较直观地说明数组是Object类的子类了，也就是说数组是对象。 但是我并不这么认为，因为我是从C,C++一步步学过来的，在我印象之中，C里面的数组就是内存中的连续的一段数据，数组的名称就是内存地址的开始位置的指针。后来这个想法就一直持续到C++里和java里。当然C里面并没有对象的说法，但是C++和java里面都有对象的说法。对于C++中，数组是不是对象我已经完全不知道了，我估计也是内存的物理地址，通过更改数组的下标就可以访问到数组的不同地址的元素。java里面我也理所当然的这么认为了。 当然，有很多机会都可以向我说明数组是对象，比如array.length，我在今天以前都认为这是java的一个为数组设计的简便获取数组长度的方式，并不认为是调用类的属性。更让我信以为真的是length后面没有()，说明不是方法。这种思维根深蒂固。 在上图中，数组通过new的方式构建出来，并没有类的声明，构造方法等，我和同学说，数组理论上来说不是类，只是JVM在处理的时候非常向一个类那样处理了。有较真的同学就更进一步指出，数组理论上来说就是一个类。 底下就完全暴露出我的不足与无知了，我反问同学： 是对象就得有类吧？构建对象怎么构建？对象内存存放位置在哪？ 还是我太无知了，我仍然天真的以为，构建对象需要用类，声明对象需要用类来声明、构造方法来完成构建，而且更要命的是我认为数组存放位置在内存中的栈中，所以我认为这几个问题都说明数组不是一个类。 同学的回答非常有说服力： 你的类难道就只是指硬盘上的.class文件？对象都是放堆上，一般是eden上，除非特别大，那就直接进老年代。hotspot虚拟机对象头元数据引用指向方法区的类元数据。类加载进来就放方法区。这种基础问题你就不用研究虚拟机了，多看看书 我还想继续反驳，但是我先去百度了一下，几乎所有人都认为数组是对象，理由就是上面那张图。而且有一切皆对象的说法。 有个帖子的分类比较好，我认为一定程度上解决了我的困惑： 引用数据类型java数据类型图： ┏数值型━┳━整数型：byte short int long ┏基本数据类型━━┫ ┗━浮点型：float do ┃ ┣字符型：char 数据类型╋ ┗布尔型：boolean ┃ ┏类（class） ┗引用数据类型━━╋接口（interface） ┗数组（array） 其实如果看到这里，把数组当成引用数据类型就解决了我的困惑。 我不放心，又去Google. java arrays are objects? 结果让我震惊，所有的人全部都在说是的。 甚至还放出了Oracal的文档，第一句就是： In the Java programming language, arrays are objects (§4.3.1), are dynamically created, and may be assigned to variables of type Object (§4.3.2). All methods of class Object may be invoked on an array. 网址：http://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html 这就让我不淡定了。 同时还有这种说法： An object is a class instance or an array. 这就说明了我的理解是错的，一个对象是一个类的实例后者是数组。 查阅更多资料后发现，数组属于特殊的类，是有JVM创建的，不像代码那样的天真。 在http://math.hws.edu/javanotes/c5/s1.html#OOP.1.4网址的5.1.4中，有更详细的说明。 As I noted in Subsection 3.8.1, arrays are objects. Like Strings they are special objects, with their own unique syntax. An array type such as int[] or String[] is actually a class, and arrays are created using a special version of the new operator. As in the case for other object variables, an array variable can never hold an actual array – only a reference to an array object. The array object itself exists in the heap. It is possible for an array variable to hold the value null, which means there is no actual array. 数组也可以指向null,它就是一个对象。 下面这个代码说明数组里可以包含对象，默认的对象并没有初始化，这里的对象是null. 12Student[] classlist; // Declare a variable of type Student[].classlist = new Student[30]; // The variable now points to an array. The array has 30 elements, classlist[0], classlist[1], … classlist[29]. When the array is created, it is filled with the default initial value, which for an object type is null. 如果需要实例化每个对象，需要这么做： 12345Student[] classlist;classlist = new Student[30];for ( int i = 0; i &lt; 30; i++ ) &#123; classlist[i] = new Student();&#125; 所以，综合这些，我确实错了。JVM可以不通过常规的类的实例化的方式构建对象。 还有最后一个问题，数组的内存存放方式，我之前认为数组放的是基本的数据类型，或者是引用数据类型（对象的引用），所以数组的存放位置是在栈区。 还是太天真了。 据http://www.cnblogs.com/hmiinyu/archive/2012/10/22/2732781.html文章说法，数组存放方式和普通对象的存放方式相同。 堆内存生成数组内容，栈内存存放数组的引用。 多维数组的存放方式如下： 这篇文章真是好文章，适合一看。 结语有时候学习东西就是先入为主，并且根深蒂固想当然。另外，这也暴露了自己的不足，就是对java自己认为很熟的东西其实并不一定是对的，另外JVM的知识我简直就是小白。总而言之，自己水平还是非常有限，需要更一步的学习。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2015%2F12%2F08%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[起源自己建立一个博客站点的想法早就有了。最起初的可能是一年前的时候，具体怎么当时怎么想的已经忘了。当时还对这些不是很了解，现在也不了解，但是不去做怎么了解呢？ 最近开始准备自己建站是因为论坛里面有一位经管的妹子发了个帖子，说经管妹子来还愿，自己成功建立一个博客站。然后我想，我也来吧。 经过妹子参考的文章是dss886大神的这篇文章：http://www.dss886.com/2014/05/05/03/，因为是论坛大水比，所以信得过。我也选了Github作为服务器。当我这几天看这个文章的时候才发现，之前的步骤我都已经做过了啊。。我竟然没点印象。直到申请fuxuemingzhu.github.io仓库的时候才发现，我原来11个月之前就已经做了这个仓库。打开主页才有一点印象，是申请过。荒废了将近一年。叹气。 按照文章里面的讲法，是用Jekyll，但是我看到妹子的文章回复里面有很多推荐Hexo的，我最终选择了Hexo。搭建文章仓库，换了几套模板。正如你现在看到的这样。 这就是我的个人博客。 现在我可以在任意时间任意地点写文章，然后发到仓库上，然后全世界的人都可以查看。 无广告，无流量限制，无访问频率限制。 感谢GitHub。 问题 文章搭建在Github上，以后打算自己租服务器。 模板不是很满意，可能还需要更换。 有点懒，里面的链接什么的还没有替换。 没时间写博客啊，打算闲着就花半小时写一点。 本地预览服务器地址改为127.0.0.1，端口号4000，否则和其他的冲突。 ===分割线2017.8.9 现在文章已经放在自己的DigitalOcean服务器上了 现在的主题挺满意 花了很久把之前用tab键敲上去的代码块换成了三个小斜杠方式 还有一个问题，在写MarkDown的时候，次标题这么写网页竟然没法正常显示： ##标题 折腾了半天才知道，Md支持这么写，Hexo要有空格才能解析： ## 标题 就是这样。 希望以后能坚持写一点东西给自己看，也希望有人可以看到我写的这些。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Ubuntu]]></title>
    <url>%2F2015%2F12%2F08%2FHello-Ubuntu%2F</url>
    <content type="text"><![CDATA[起源其实早就想换上Linux了，最近在论坛里见到不少大神都在讲自己的Linux情况，还见到一个学长表示自己已入坑，所以我想我是不是应该也装上Linux玩一玩（装装逼）。 经过因为自己虽然会写两行代码，但是动手能力实在不强。俗话说得好，“你都大二了还不回装系统？”，嗯，我大三了都不会。另外我胆小，怕把电脑弄坏了，更重要的是我有拖延症，所以一直没弄。期中考试之后，打算弄一下，碰巧见到论坛里有用 EasyBCD 装Ubuntu的，所以我终于决定了一次，搞吧！ 首先是选哪个系统的问题。这个我确实小白，不知道哪个合适，见论坛里和网上倾向于乌班图的人数比较多，所以就选了这个系统= =，其实我真不知道其他的系统怎么样。 然后，选用哪个方法去装系统呢？ 我在见到论坛帖子之前，在网上搜了不少经验贴。起初决定用这个：http://jingyan.baidu.com/article/c275f6bacc3326e33c756743.html，用U盘去装双系统。 我感觉挺合适的，讲得也非常清楚。。嗯，我的U盘找不到了。 在论坛里的一个关于用EasyBCD装系统的帖子中，我发现了这样的一个回帖： I have successfully installed Ubuntu with easybcd following Baidu Tips a few days ago. Here is the link. Follow it step by step and you will make it out.http://jingyan.baidu.com/article/e4d08ffdace06e0fd2f60d39.html 而且层主的坐标是美国加州大学，我就感觉靠谱，说做就做吧！ 安装步骤就是安装上面回帖的网址做的，因为我只有一台电脑，而且没有经验。遇到问题就卡BUG了。安装的时候遇到了好几次问题，都是退出了然后回到WIN7下查资料。反复弄了好几次。 讲一下遇到的最糟糕的问题。设立分区的问题，就是经验中的这一步：http://jingyan.baidu.com/album/e4d08ffdace06e0fd2f60d39.html?picindex=21 我的电脑在这里并没有空闲的那个分区。我就蒙了。难道把其他的已有的分区改了么？（还好没这么做，要不然电脑就清空了），点了确定之后，英文提醒我是否确定擦除硬盘内容？还好我比较谨慎，感觉有问题，就没点继续。在反复确定之后，我认为是应该给Ubuntu一个独立的系统磁盘空间，也就是磁盘分区。 之前用到过分区助手，所以这个我还是有点经验的，就把F:盘分了30G空闲盘叫做M:。重启进入Ubuntu，发现这个盘确实在，然后就把这个盘给清空了。按照经验的做法，顺利的完成了。 安装完成之后，再进入Win7把EasyBCD里的设置给删除了，防止每次开机都有可以装系统的提醒。 而且我发现M：盘奇迹般的没有了。。我以为像Win7的C:盘一样存在着可以看到的。我猜想是擦除磁盘的时候，把盘里面默认的大概50M左右的已用空间给擦了，这个空间是声明这个盘的状态的。 总之，至此，Ubuntu成功安装，虽然开机之后进入Ubuntu我除了上网什么都不会干，但是那个网速可是刷刷的呀。而且关机时间大概5秒左右，还是挺快的。 后续本来好好的，没想到会有后续。 第二天早晨，开机玩Ubuntu，熟悉快捷键嘛。。想的挺好的。百度了一下，第一条，百度知道，sudo startx，嗯。挺好的。电脑只剩下壁纸了。 连关机选项都没有。真的什么都不剩了。。蒙了。 折腾不好了，最后一节有考试，电脑装在背包里去教室了。 背着感觉不太对呀，好烫。 因为考试也没太注意它，下课了，烫得要命，电脑指示灯显示没电了。 这不对呀，Ubuntu发热这么严重啊！我Win7的情况下塞包里面一点问题都没有啊！ 别说了，赶紧关机吧，要不然烧了主板了。 只有壁纸，没有关机。。 直接电源键！ 好的，终于关掉了。庆幸。 下午，自习，充上电，打开电脑，正常，庆幸。 嗯，要输入Ubuntu的密码，好哒，确认，黑屏，要重新输入。 可是没错呀！这怎么回事，一直要重新输入。 没辙了，进入Win7查资料，都试了，不好使。 上论坛求救吧。这里要赞下我们的论坛，很快就收到了两个大神的帮助。 虽然论坛交流缓慢，但是感谢暖羊羊大神，耐心的询问我的电脑症状，然后用Ctrl+AltF1进入紧急状态命令行，打了句 1sudo chown -R yourname: . 把yourname替换成你的用户名。那几个空格的位置不要搞错。如果怕搞错，输入下面这个也行： 1sudo chown -R yourname: . 之后就恢复正常了。 原因是因为，把.Xauthority文件的属性改成了root，正常情况下应该是我的用户名。恢复了就好了。 补充到此基本就没什么了，感谢论坛里各位同学的帮助。后来发现不少童鞋都有我这个相同的问题，默默骂了句Ubuntu挺坑。还有同学建议不要在生产生活环境里面学命令，可以在虚拟机里面学习。还有不要装搜狗输入法什么的。（我装了= =，不能登录我的账号同步词库，略坑）。 另外没想到问题解决的第二天，我的求救贴还能上了十大。可我问题已经解决了呀。哈哈，感谢各位同学。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F12%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
      </tags>
  </entry>
</search>
